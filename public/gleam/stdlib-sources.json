{"gleam/bit_array":"//// BitArrays are a sequence of binary data of any length.\n\nimport gleam/int\nimport gleam/order\nimport gleam/string\n\n/// Converts a UTF-8 `String` type into a `BitArray`.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_from_string\")\npub fn from_string(x: String) -> BitArray\n\n/// Returns an integer which is the number of bits in the bit array.\n///\n@external(erlang, \"erlang\", \"bit_size\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_bit_size\")\npub fn bit_size(x: BitArray) -> Int\n\n/// Returns an integer which is the number of bytes in the bit array.\n///\n@external(erlang, \"erlang\", \"byte_size\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_byte_size\")\npub fn byte_size(x: BitArray) -> Int\n\n/// Pads a bit array with zeros so that it is a whole number of bytes.\n///\n@external(erlang, \"gleam_stdlib\", \"bit_array_pad_to_bytes\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_pad_to_bytes\")\npub fn pad_to_bytes(x: BitArray) -> BitArray\n\n/// Creates a new bit array by joining two bit arrays.\n///\n/// ## Examples\n///\n/// ```gleam\n/// append(to: from_string(\"butter\"), suffix: from_string(\"fly\"))\n/// // -> from_string(\"butterfly\")\n/// ```\n///\npub fn append(to first: BitArray, suffix second: BitArray) -> BitArray {\n  concat([first, second])\n}\n\n/// Extracts a sub-section of a bit array.\n///\n/// The slice will start at given position and continue up to specified\n/// length.\n/// A negative length can be used to extract bytes at the end of a bit array.\n///\n/// This function runs in constant time.\n///\n@external(erlang, \"gleam_stdlib\", \"bit_array_slice\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_slice\")\npub fn slice(\n  from string: BitArray,\n  at position: Int,\n  take length: Int,\n) -> Result(BitArray, Nil)\n\n/// Tests to see whether a bit array is valid UTF-8.\n///\npub fn is_utf8(bits: BitArray) -> Bool {\n  is_utf8_loop(bits)\n}\n\n@target(erlang)\nfn is_utf8_loop(bits: BitArray) -> Bool {\n  case bits {\n    <<>> -> True\n    <<_:utf8, rest:bytes>> -> is_utf8_loop(rest)\n    _ -> False\n  }\n}\n\n@target(javascript)\nfn is_utf8_loop(bits: BitArray) -> Bool {\n  case to_string(bits) {\n    Ok(_) -> True\n    Error(_) -> False\n  }\n}\n\n/// Converts a bit array to a string.\n///\n/// Returns an error if the bit array is invalid UTF-8 data.\n///\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_to_string\")\npub fn to_string(bits: BitArray) -> Result(String, Nil) {\n  case is_utf8(bits) {\n    True -> Ok(unsafe_to_string(bits))\n    False -> Error(Nil)\n  }\n}\n\n@external(erlang, \"gleam_stdlib\", \"identity\")\nfn unsafe_to_string(a: BitArray) -> String\n\n/// Creates a new bit array by joining multiple binaries.\n///\n/// ## Examples\n///\n/// ```gleam\n/// concat([from_string(\"butter\"), from_string(\"fly\")])\n/// // -> from_string(\"butterfly\")\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"bit_array_concat\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_concat\")\npub fn concat(bit_arrays: List(BitArray)) -> BitArray\n\n/// Encodes a BitArray into a base 64 encoded string.\n///\n/// If the bit array does not contain a whole number of bytes then it is padded\n/// with zero bits prior to being encoded.\n///\n@external(erlang, \"gleam_stdlib\", \"base64_encode\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"base64_encode\")\npub fn base64_encode(input: BitArray, padding: Bool) -> String\n\n/// Decodes a base 64 encoded string into a `BitArray`.\n///\npub fn base64_decode(encoded: String) -> Result(BitArray, Nil) {\n  let padded = case byte_size(from_string(encoded)) % 4 {\n    0 -> encoded\n    n -> string.append(encoded, string.repeat(\"=\", 4 - n))\n  }\n  decode64(padded)\n}\n\n@external(erlang, \"gleam_stdlib\", \"base64_decode\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"base64_decode\")\nfn decode64(a: String) -> Result(BitArray, Nil)\n\n/// Encodes a `BitArray` into a base 64 encoded string with URL and filename\n/// safe alphabet.\n///\n/// If the bit array does not contain a whole number of bytes then it is padded\n/// with zero bits prior to being encoded.\n///\npub fn base64_url_encode(input: BitArray, padding: Bool) -> String {\n  input\n  |> base64_encode(padding)\n  |> string.replace(\"+\", \"-\")\n  |> string.replace(\"/\", \"_\")\n}\n\n/// Decodes a base 64 encoded string with URL and filename safe alphabet into a\n/// `BitArray`.\n///\npub fn base64_url_decode(encoded: String) -> Result(BitArray, Nil) {\n  encoded\n  |> string.replace(\"-\", \"+\")\n  |> string.replace(\"_\", \"/\")\n  |> base64_decode()\n}\n\n/// Encodes a `BitArray` into a base 16 encoded string.\n///\n/// If the bit array does not contain a whole number of bytes then it is padded\n/// with zero bits prior to being encoded.\n///\n@external(erlang, \"gleam_stdlib\", \"base16_encode\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"base16_encode\")\npub fn base16_encode(input: BitArray) -> String\n\n/// Decodes a base 16 encoded string into a `BitArray`.\n///\n@external(erlang, \"gleam_stdlib\", \"base16_decode\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"base16_decode\")\npub fn base16_decode(input: String) -> Result(BitArray, Nil)\n\n/// Converts a bit array to a string containing the decimal value of each byte.\n///\n/// Use this over `string.inspect` when you have a bit array you want printed\n/// in the array syntax even if it is valid UTF-8.\n///\n/// ## Examples\n///\n/// ```gleam\n/// inspect(<<0, 20, 0x20, 255>>)\n/// // -> \"<<0, 20, 32, 255>>\"\n///\n/// inspect(<<100, 5:3>>)\n/// // -> \"<<100, 5:size(3)>>\"\n/// ```\n///\npub fn inspect(input: BitArray) -> String {\n  inspect_loop(input, \"<<\") <> \">>\"\n}\n\nfn inspect_loop(input: BitArray, accumulator: String) -> String {\n  case input {\n    <<>> -> accumulator\n\n    <<x:size(1)>> -> accumulator <> int.to_string(x) <> \":size(1)\"\n    <<x:size(2)>> -> accumulator <> int.to_string(x) <> \":size(2)\"\n    <<x:size(3)>> -> accumulator <> int.to_string(x) <> \":size(3)\"\n    <<x:size(4)>> -> accumulator <> int.to_string(x) <> \":size(4)\"\n    <<x:size(5)>> -> accumulator <> int.to_string(x) <> \":size(5)\"\n    <<x:size(6)>> -> accumulator <> int.to_string(x) <> \":size(6)\"\n    <<x:size(7)>> -> accumulator <> int.to_string(x) <> \":size(7)\"\n\n    <<x, rest:bits>> -> {\n      let suffix = case rest {\n        <<>> -> \"\"\n        _ -> \", \"\n      }\n\n      let accumulator = accumulator <> int.to_string(x) <> suffix\n      inspect_loop(rest, accumulator)\n    }\n\n    _ -> accumulator\n  }\n}\n\n/// Compare two bit arrays as sequences of bytes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// compare(<<1>>, <<2>>)\n/// // -> Lt\n///\n/// compare(<<\"AB\":utf8>>, <<\"AA\":utf8>>)\n/// // -> Gt\n///\n/// compare(<<1, 2:size(2)>>, with: <<1, 2:size(2)>>)\n/// // -> Eq\n/// ```\n///\npub fn compare(a: BitArray, with b: BitArray) -> order.Order {\n  case a, b {\n    <<first_byte, first_rest:bits>>, <<second_byte, second_rest:bits>> ->\n      case first_byte, second_byte {\n        f, s if f > s -> order.Gt\n        f, s if f < s -> order.Lt\n        _, _ -> compare(first_rest, second_rest)\n      }\n\n    <<>>, <<>> -> order.Eq\n    // First has more items, example: \"AB\" > \"A\":\n    _, <<>> -> order.Gt\n    // Second has more items, example: \"A\" < \"AB\":\n    <<>>, _ -> order.Lt\n    // This happens when there's unusually sized elements.\n    // Handle these special cases via custom erlang function.\n    first, second ->\n      case bit_array_to_int_and_size(first), bit_array_to_int_and_size(second) {\n        #(a, _), #(b, _) if a > b -> order.Gt\n        #(a, _), #(b, _) if a < b -> order.Lt\n        #(_, size_a), #(_, size_b) if size_a > size_b -> order.Gt\n        #(_, size_a), #(_, size_b) if size_a < size_b -> order.Lt\n        _, _ -> order.Eq\n      }\n  }\n}\n\n@external(erlang, \"gleam_stdlib\", \"bit_array_to_int_and_size\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_to_int_and_size\")\nfn bit_array_to_int_and_size(a: BitArray) -> #(Int, Int)\n\n/// Checks whether the first `BitArray` starts with the second one.\n///\n/// ## Examples\n///\n/// ```gleam\n/// starts_with(<<1, 2, 3, 4>>, <<1, 2>>)\n/// // -> True\n/// ```\n///\n@external(javascript, \"../gleam_stdlib.mjs\", \"bit_array_starts_with\")\npub fn starts_with(bits: BitArray, prefix: BitArray) -> Bool {\n  let prefix_size = bit_size(prefix)\n\n  case bits {\n    <<pref:bits-size(prefix_size), _:bits>> if pref == prefix -> True\n    _ -> False\n  }\n}\n","gleam/bool":"//// A type with two possible values, `True` and `False`. Used to indicate whether\n//// things are... true or false!\n////\n//// It is often clearer and offers more type safety to define a custom type\n//// than to use `Bool`. For example, rather than having a `is_teacher: Bool`\n//// field consider having a `role: SchoolRole` field where `SchoolRole` is a custom\n//// type that can be either `Student` or `Teacher`.\n\n/// Returns the and of two bools, but it evaluates both arguments.\n///\n/// It's the function equivalent of the `&&` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// and(True, True)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// and(False, True)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// False |> and(True)\n/// // -> False\n/// ```\n///\npub fn and(a: Bool, b: Bool) -> Bool {\n  a && b\n}\n\n/// Returns the or of two bools, but it evaluates both arguments.\n///\n/// It's the function equivalent of the `||` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// or(True, True)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// or(False, True)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// False |> or(True)\n/// // -> True\n/// ```\n///\npub fn or(a: Bool, b: Bool) -> Bool {\n  a || b\n}\n\n/// Returns the opposite bool value.\n///\n/// This is the same as the `!` or `not` operators in some other languages.\n///\n/// ## Examples\n///\n/// ```gleam\n/// negate(True)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// negate(False)\n/// // -> True\n/// ```\n///\npub fn negate(bool: Bool) -> Bool {\n  !bool\n}\n\n/// Returns the nor of two bools.\n///\n/// ## Examples\n///\n/// ```gleam\n/// nor(False, False)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// nor(False, True)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// nor(True, False)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// nor(True, True)\n/// // -> False\n/// ```\n///\npub fn nor(a: Bool, b: Bool) -> Bool {\n  !{ a || b }\n}\n\n/// Returns the nand of two bools.\n///\n/// ## Examples\n///\n/// ```gleam\n/// nand(False, False)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// nand(False, True)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// nand(True, False)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// nand(True, True)\n/// // -> False\n/// ```\n///\npub fn nand(a: Bool, b: Bool) -> Bool {\n  !{ a && b }\n}\n\n/// Returns the exclusive or of two bools.\n///\n/// ## Examples\n///\n/// ```gleam\n/// exclusive_or(False, False)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// exclusive_or(False, True)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// exclusive_or(True, False)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// exclusive_or(True, True)\n/// // -> False\n/// ```\n///\npub fn exclusive_or(a: Bool, b: Bool) -> Bool {\n  a != b\n}\n\n/// Returns the exclusive nor of two bools.\n///\n/// ## Examples\n///\n/// ```gleam\n/// exclusive_nor(False, False)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// exclusive_nor(False, True)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// exclusive_nor(True, False)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// exclusive_nor(True, True)\n/// // -> True\n/// ```\n///\npub fn exclusive_nor(a: Bool, b: Bool) -> Bool {\n  a == b\n}\n\n/// Returns a string representation of the given bool.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_string(True)\n/// // -> \"True\"\n/// ```\n///\n/// ```gleam\n/// to_string(False)\n/// // -> \"False\"\n/// ```\n///\npub fn to_string(bool: Bool) -> String {\n  case bool {\n    False -> \"False\"\n    True -> \"True\"\n  }\n}\n\n/// Run a callback function if the given bool is `False`, otherwise return a\n/// default value.\n///\n/// With a `use` expression this function can simulate the early-return pattern\n/// found in some other programming languages.\n///\n/// In a procedural language:\n///\n/// ```js\n/// if (predicate) return value;\n/// // ...\n/// ```\n///\n/// In Gleam with a `use` expression:\n///\n/// ```gleam\n/// use <- guard(when: predicate, return: value)\n/// // ...\n/// ```\n///\n/// Like everything in Gleam `use` is an expression, so it short circuits the\n/// current block, not the entire function. As a result you can assign the value\n/// to a variable:\n///\n/// ```gleam\n/// let x = {\n///   use <- guard(when: predicate, return: value)\n///   // ...\n/// }\n/// ```\n///\n/// Note that unlike in procedural languages the `return` value is evaluated\n/// even when the predicate is `False`, so it is advisable not to perform\n/// expensive computation nor side-effects there.\n///\n///\n/// ## Examples\n///\n/// ```gleam\n/// let name = \"\"\n/// use <- guard(when: name == \"\", return: \"Welcome!\")\n/// \"Hello, \" <> name\n/// // -> \"Welcome!\"\n/// ```\n///\n/// ```gleam\n/// let name = \"Kamaka\"\n/// use <- guard(when: name == \"\", return: \"Welcome!\")\n/// \"Hello, \" <> name\n/// // -> \"Hello, Kamaka\"\n/// ```\n///\npub fn guard(\n  when requirement: Bool,\n  return consequence: a,\n  otherwise alternative: fn() -> a,\n) -> a {\n  case requirement {\n    True -> consequence\n    False -> alternative()\n  }\n}\n\n/// Runs a callback function if the given bool is `True`, otherwise runs an\n/// alternative callback function.\n///\n/// Useful when further computation should be delayed regardless of the given\n/// bool's value.\n///\n/// See [`guard`](#guard) for more info.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let name = \"Kamaka\"\n/// let inquiry = fn() { \"How may we address you?\" }\n/// use <- lazy_guard(when: name == \"\", return: inquiry)\n/// \"Hello, \" <> name\n/// // -> \"Hello, Kamaka\"\n/// ```\n///\n/// ```gleam\n/// import gleam/int\n///\n/// let name = \"\"\n/// let greeting = fn() { \"Hello, \" <> name }\n/// use <- lazy_guard(when: name == \"\", otherwise: greeting)\n/// let number = int.random(99)\n/// let name = \"User \" <> int.to_string(number)\n/// \"Welcome, \" <> name\n/// // -> \"Welcome, User 54\"\n/// ```\n///\npub fn lazy_guard(\n  when requirement: Bool,\n  return consequence: fn() -> a,\n  otherwise alternative: fn() -> a,\n) -> a {\n  case requirement {\n    True -> consequence()\n    False -> alternative()\n  }\n}\n","gleam/bytes_tree":"//// `BytesTree` is a type used for efficiently building binary content to be\n//// written to a file or a socket. Internally it is represented as a tree so to\n//// append or prepend to a bytes tree is a constant time operation that\n//// allocates a new node in the tree without copying any of the content. When\n//// writing to an output stream the tree is traversed and the content is sent\n//// directly rather than copying it into a single buffer beforehand.\n////\n//// If we append one bit array to another the bit arrays must be copied to a\n//// new location in memory so that they can sit together. This behaviour\n//// enables efficient reading of the data but copying can be expensive,\n//// especially if we want to join many bit arrays together.\n////\n//// BytesTree is different in that it can be joined together in constant\n//// time using minimal memory, and then can be efficiently converted to a\n//// bit array using the `to_bit_array` function.\n////\n//// Byte trees are always byte aligned, so that a number of bits that is not\n//// divisible by 8 will be padded with 0s.\n////\n//// On Erlang this type is compatible with Erlang's iolists.\n\nimport gleam/bit_array\nimport gleam/list\nimport gleam/string_tree.{type StringTree}\n\npub opaque type BytesTree {\n  Bytes(BitArray)\n  Text(StringTree)\n  Many(List(BytesTree))\n}\n\n/// Create an empty `BytesTree`. Useful as the start of a pipe chaining many\n/// trees together.\n///\npub fn new() -> BytesTree {\n  concat([])\n}\n\n/// Prepends a bit array to the start of a bytes tree.\n///\n/// Runs in constant time.\n///\npub fn prepend(to second: BytesTree, prefix first: BitArray) -> BytesTree {\n  append_tree(from_bit_array(first), second)\n}\n\n/// Appends a bit array to the end of a bytes tree.\n///\n/// Runs in constant time.\n///\npub fn append(to first: BytesTree, suffix second: BitArray) -> BytesTree {\n  append_tree(first, from_bit_array(second))\n}\n\n/// Prepends a bytes tree onto the start of another.\n///\n/// Runs in constant time.\n///\npub fn prepend_tree(to second: BytesTree, prefix first: BytesTree) -> BytesTree {\n  append_tree(first, second)\n}\n\n/// Appends a bytes tree onto the end of another.\n///\n/// Runs in constant time.\n///\n@external(erlang, \"gleam_stdlib\", \"iodata_append\")\npub fn append_tree(to first: BytesTree, suffix second: BytesTree) -> BytesTree {\n  case second {\n    Many(trees) -> Many([first, ..trees])\n    Text(_) | Bytes(_) -> Many([first, second])\n  }\n}\n\n/// Prepends a string onto the start of a bytes tree.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time with the length of the string otherwise.\n///\npub fn prepend_string(to second: BytesTree, prefix first: String) -> BytesTree {\n  append_tree(from_string(first), second)\n}\n\n/// Appends a string onto the end of a bytes tree.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time with the length of the string otherwise.\n///\npub fn append_string(to first: BytesTree, suffix second: String) -> BytesTree {\n  append_tree(first, from_string(second))\n}\n\n/// Joins a list of bytes trees into a single one.\n///\n/// Runs in constant time.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\npub fn concat(trees: List(BytesTree)) -> BytesTree {\n  Many(trees)\n}\n\n/// Joins a list of bit arrays into a single bytes tree.\n///\n/// Runs in constant time.\n///\npub fn concat_bit_arrays(bits: List(BitArray)) -> BytesTree {\n  bits\n  |> list.map(from_bit_array)\n  |> concat()\n}\n\n/// Creates a new bytes tree from a string.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time otherwise.\n///\n@external(erlang, \"gleam_stdlib\", \"wrap_list\")\npub fn from_string(string: String) -> BytesTree {\n  Text(string_tree.from_string(string))\n}\n\n/// Creates a new bytes tree from a string tree.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time otherwise.\n///\n@external(erlang, \"gleam_stdlib\", \"wrap_list\")\npub fn from_string_tree(tree: string_tree.StringTree) -> BytesTree {\n  Text(tree)\n}\n\n/// Creates a new bytes tree from a bit array.\n///\n/// Runs in constant time.\n///\npub fn from_bit_array(bits: BitArray) -> BytesTree {\n  bits\n  |> bit_array.pad_to_bytes\n  |> wrap_list\n}\n\n@external(erlang, \"gleam_stdlib\", \"wrap_list\")\nfn wrap_list(bits: BitArray) -> BytesTree {\n  Bytes(bits)\n}\n\n/// Turns a bytes tree into a bit array.\n///\n/// Runs in linear time.\n///\n/// When running on Erlang this function is implemented natively by the\n/// virtual machine and is highly optimised.\n///\n@external(erlang, \"erlang\", \"list_to_bitstring\")\npub fn to_bit_array(tree: BytesTree) -> BitArray {\n  [[tree]]\n  |> to_list([])\n  |> list.reverse\n  |> bit_array.concat\n}\n\nfn to_list(stack: List(List(BytesTree)), acc: List(BitArray)) -> List(BitArray) {\n  case stack {\n    [] -> acc\n\n    [[], ..remaining_stack] -> to_list(remaining_stack, acc)\n\n    [[Bytes(bits), ..rest], ..remaining_stack] ->\n      to_list([rest, ..remaining_stack], [bits, ..acc])\n\n    [[Text(tree), ..rest], ..remaining_stack] -> {\n      let bits = bit_array.from_string(string_tree.to_string(tree))\n      to_list([rest, ..remaining_stack], [bits, ..acc])\n    }\n\n    [[Many(trees), ..rest], ..remaining_stack] ->\n      to_list([trees, rest, ..remaining_stack], acc)\n  }\n}\n\n/// Returns the size of the bytes tree's content in bytes.\n///\n/// Runs in linear time.\n///\n@external(erlang, \"erlang\", \"iolist_size\")\npub fn byte_size(tree: BytesTree) -> Int {\n  [[tree]]\n  |> to_list([])\n  |> list.fold(0, fn(acc, bits) { bit_array.byte_size(bits) + acc })\n}\n","gleam/dict":"import gleam/option.{type Option}\n\n/// A dictionary of keys and values.\n///\n/// Any type can be used for the keys and values of a dict, but all the keys\n/// must be of the same type and all the values must be of the same type.\n///\n/// Each key can only be present in a dict once.\n///\n/// Dicts are not ordered in any way, and any unintentional ordering is not to\n/// be relied upon in your code as it may change in future versions of Erlang\n/// or Gleam.\n///\n/// See [the Erlang map module](https://erlang.org/doc/man/maps.html) for more\n/// information.\n///\npub type Dict(key, value)\n\n/// \"TransientDict\" is a mutable view on a dictionary used internally by the\n/// JavaScript target. No mutable API is exposed to the user.\n///\n/// Transients are to be treated as having a linear (single-use, think rust) type.\n/// A transient value becomes invalid as soon as it's passed to one of the functions.\ntype TransientDict(key, value)\n\n/// Convert a normal Dict to a transient dict.\n/// A transient dict is a mutable copy of the original.\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../dict.mjs\", \"toTransient\")\nfn to_transient(dict: Dict(key, value)) -> TransientDict(key, value)\n\n/// Convert a transient dict back into a normal dict, freezing its contents.\n/// Using the transient after this point is highly unsafe and leads to undefined behavior.\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../dict.mjs\", \"fromTransient\")\nfn from_transient(transient: TransientDict(key, value)) -> Dict(key, value)\n\n/// Determines the number of key-value pairs in the dict.\n/// This function runs in constant time and does not need to iterate the dict.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new() |> size\n/// // -> 0\n/// ```\n///\n/// ```gleam\n/// new() |> insert(\"key\", \"value\") |> size\n/// // -> 1\n/// ```\n///\n@external(erlang, \"maps\", \"size\")\n@external(javascript, \"../dict.mjs\", \"size\")\npub fn size(dict: Dict(k, v)) -> Int\n\n/// Determines whether or not the dict is empty.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new() |> is_empty\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// new() |> insert(\"b\", 1) |> is_empty\n/// // -> False\n/// ```\n///\npub fn is_empty(dict: Dict(k, v)) -> Bool {\n  size(dict) == 0\n}\n\n/// Converts the dict to a list of 2-element tuples `#(key, value)`, one for\n/// each key-value pair in the dict.\n///\n/// The tuples in the list have no specific order.\n///\n/// ## Examples\n///\n/// Calling `to_list` on an empty `dict` returns an empty list.\n///\n/// ```gleam\n/// new() |> to_list\n/// // -> []\n/// ```\n///\n/// The ordering of elements in the resulting list is an implementation detail\n/// that should not be relied upon.\n///\n/// ```gleam\n/// new() |> insert(\"b\", 1) |> insert(\"a\", 0) |> insert(\"c\", 2) |> to_list\n/// // -> [#(\"a\", 0), #(\"b\", 1), #(\"c\", 2)]\n/// ```\n///\n@external(erlang, \"maps\", \"to_list\")\npub fn to_list(dict: Dict(k, v)) -> List(#(k, v)) {\n  fold(dict, from: [], with: fn(acc, key, value) { [#(key, value), ..acc] })\n}\n\n/// Converts a list of 2-element tuples `#(key, value)` to a dict.\n///\n/// If two tuples have the same key the last one in the list will be the one\n/// that is present in the dict.\n///\n@external(erlang, \"maps\", \"from_list\")\npub fn from_list(list: List(#(k, v))) -> Dict(k, v) {\n  from_list_loop(to_transient(new()), list)\n}\n\nfn from_list_loop(\n  transient: TransientDict(k, v),\n  list: List(#(k, v)),\n) -> Dict(k, v) {\n  case list {\n    [] -> from_transient(transient)\n    [#(key, value), ..rest] ->\n      from_list_loop(transient_insert(key, value, transient), rest)\n  }\n}\n\n/// Determines whether or not a value is present in the dict for a given key.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new() |> insert(\"a\", 0) |> has_key(\"a\")\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// new() |> insert(\"a\", 0) |> has_key(\"b\")\n/// // -> False\n/// ```\n///\n@external(javascript, \"../dict.mjs\", \"has\")\npub fn has_key(dict: Dict(k, v), key: k) -> Bool {\n  do_has_key(key, dict)\n}\n\n@external(erlang, \"maps\", \"is_key\")\nfn do_has_key(key: k, dict: Dict(k, v)) -> Bool\n\n/// Creates a fresh dict that contains no values.\n///\n@external(erlang, \"maps\", \"new\")\n@external(javascript, \"../dict.mjs\", \"make\")\npub fn new() -> Dict(k, v)\n\n/// Fetches a value from a dict for a given key.\n///\n/// The dict may not have a value for the key, so the value is wrapped in a\n/// `Result`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new() |> insert(\"a\", 0) |> get(\"a\")\n/// // -> Ok(0)\n/// ```\n///\n/// ```gleam\n/// new() |> insert(\"a\", 0) |> get(\"b\")\n/// // -> Error(Nil)\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"map_get\")\n@external(javascript, \"../dict.mjs\", \"get\")\npub fn get(from: Dict(k, v), get: k) -> Result(v, Nil)\n\n/// Inserts a value into the dict with the given key.\n///\n/// If the dict already has a value for the given key then the value is\n/// replaced with the new value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new() |> insert(\"a\", 0)\n/// // -> from_list([#(\"a\", 0)])\n/// ```\n///\n/// ```gleam\n/// new() |> insert(\"a\", 0) |> insert(\"a\", 5)\n/// // -> from_list([#(\"a\", 5)])\n/// ```\n///\n@external(javascript, \"../dict.mjs\", \"insert\")\npub fn insert(into dict: Dict(k, v), for key: k, insert value: v) -> Dict(k, v) {\n  do_insert(key, value, dict)\n}\n\n@external(erlang, \"maps\", \"put\")\nfn do_insert(key: k, value: v, dict: Dict(k, v)) -> Dict(k, v)\n\n@external(erlang, \"maps\", \"put\")\n@external(javascript, \"../dict.mjs\", \"destructiveTransientInsert\")\nfn transient_insert(\n  key: k,\n  value: v,\n  transient: TransientDict(k, v),\n) -> TransientDict(k, v)\n\n/// Updates all values in a given dict by calling a given function on each key\n/// and value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([#(3, 3), #(2, 4)])\n/// |> map_values(fn(key, value) { key * value })\n/// // -> from_list([#(3, 9), #(2, 8)])\n/// ```\n///\n@external(javascript, \"../dict.mjs\", \"map\")\npub fn map_values(in dict: Dict(k, v), with fun: fn(k, v) -> a) -> Dict(k, a) {\n  do_map_values(fun, dict)\n}\n\n@external(erlang, \"maps\", \"map\")\nfn do_map_values(f: fn(k, v) -> a, dict: Dict(k, v)) -> Dict(k, a)\n\n/// Gets a list of all keys in a given dict.\n///\n/// Dicts are not ordered so the keys are not returned in any specific order. Do\n/// not write code that relies on the order keys are returned by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)]) |> keys\n/// // -> [\"a\", \"b\"]\n/// ```\n///\n@external(erlang, \"maps\", \"keys\")\npub fn keys(dict: Dict(k, v)) -> List(k) {\n  fold(dict, [], fn(acc, key, _value) { [key, ..acc] })\n}\n\n/// Gets a list of all values in a given dict.\n///\n/// Dicts are not ordered so the values are not returned in any specific order. Do\n/// not write code that relies on the order values are returned by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)]) |> values\n/// // -> [0, 1]\n/// ```\n///\n@external(erlang, \"maps\", \"values\")\npub fn values(dict: Dict(k, v)) -> List(v) {\n  fold(dict, [], fn(acc, _key, value) { [value, ..acc] })\n}\n\n/// Creates a new dict from a given dict, minus any entries that a given function\n/// returns `False` for.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)])\n/// |> filter(fn(key, value) { value != 0 })\n/// // -> from_list([#(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)])\n/// |> filter(fn(key, value) { True })\n/// // -> from_list([#(\"a\", 0), #(\"b\", 1)])\n/// ```\n///\npub fn filter(\n  in dict: Dict(k, v),\n  keeping predicate: fn(k, v) -> Bool,\n) -> Dict(k, v) {\n  do_filter(predicate, dict)\n}\n\n@external(erlang, \"maps\", \"filter\")\nfn do_filter(f: fn(k, v) -> Bool, dict: Dict(k, v)) -> Dict(k, v) {\n  to_transient(new())\n  |> fold(over: dict, with: fn(transient, key, value) {\n    case f(key, value) {\n      True -> transient_insert(key, value, transient)\n      False -> transient\n    }\n  })\n  |> from_transient\n}\n\n/// Creates a new dict from a given dict, only including any entries for which the\n/// keys are in a given list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)])\n/// |> take([\"b\"])\n/// // -> from_list([#(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)])\n/// |> take([\"a\", \"b\", \"c\"])\n/// // -> from_list([#(\"a\", 0), #(\"b\", 1)])\n/// ```\n///\npub fn take(from dict: Dict(k, v), keeping desired_keys: List(k)) -> Dict(k, v) {\n  do_take(desired_keys, dict)\n}\n\n@external(erlang, \"maps\", \"with\")\nfn do_take(desired_keys: List(k), dict: Dict(k, v)) -> Dict(k, v) {\n  do_take_loop(dict, desired_keys, to_transient(new()))\n}\n\nfn do_take_loop(\n  dict: Dict(k, v),\n  desired_keys: List(k),\n  acc: TransientDict(k, v),\n) -> Dict(k, v) {\n  case desired_keys {\n    [] -> from_transient(acc)\n    [key, ..rest] ->\n      case get(dict, key) {\n        Ok(value) -> do_take_loop(dict, rest, transient_insert(key, value, acc))\n        Error(_) -> do_take_loop(dict, rest, acc)\n      }\n  }\n}\n\n/// Creates a new dict from a pair of given dicts by combining their entries.\n///\n/// If there are entries with the same keys in both dicts the entry from the\n/// second dict takes precedence.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let a = from_list([#(\"a\", 0), #(\"b\", 1)])\n/// let b = from_list([#(\"b\", 2), #(\"c\", 3)])\n/// merge(a, b)\n/// // -> from_list([#(\"a\", 0), #(\"b\", 2), #(\"c\", 3)])\n/// ```\n///\n@external(erlang, \"maps\", \"merge\")\npub fn merge(into dict: Dict(k, v), from new_entries: Dict(k, v)) -> Dict(k, v) {\n  combine(dict, new_entries, fn(_, new_entry) { new_entry })\n}\n\n/// Creates a new dict from a given dict with all the same entries except for the\n/// one with a given key, if it exists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)]) |> delete(\"a\")\n/// // -> from_list([#(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)]) |> delete(\"c\")\n/// // -> from_list([#(\"a\", 0), #(\"b\", 1)])\n/// ```\n///\npub fn delete(from dict: Dict(k, v), delete key: k) -> Dict(k, v) {\n  to_transient(dict) |> transient_delete(key, _) |> from_transient\n}\n\n@external(erlang, \"maps\", \"remove\")\n@external(javascript, \"../dict.mjs\", \"destructiveTransientDelete\")\nfn transient_delete(a: k, b: TransientDict(k, v)) -> TransientDict(k, v)\n\n/// Creates a new dict from a given dict with all the same entries except any with\n/// keys found in a given list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)]) |> drop([\"a\"])\n/// // -> from_list([#(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)]) |> drop([\"c\"])\n/// // -> from_list([#(\"a\", 0), #(\"b\", 1)])\n/// ```\n///\n/// ```gleam\n/// from_list([#(\"a\", 0), #(\"b\", 1)]) |> drop([\"a\", \"b\", \"c\"])\n/// // -> from_list([])\n/// ```\n///\npub fn drop(from dict: Dict(k, v), drop disallowed_keys: List(k)) -> Dict(k, v) {\n  do_drop(disallowed_keys, dict)\n}\n\n@external(erlang, \"maps\", \"without\")\nfn do_drop(disallowed_keys: List(k), dict: Dict(k, v)) -> Dict(k, v) {\n  drop_loop(to_transient(dict), disallowed_keys)\n}\n\nfn drop_loop(\n  transient: TransientDict(k, v),\n  disallowed_keys: List(k),\n) -> Dict(k, v) {\n  case disallowed_keys {\n    [] -> from_transient(transient)\n    [key, ..rest] -> drop_loop(transient_delete(key, transient), rest)\n  }\n}\n\n/// Creates a new dict with one entry inserted or updated using a given function.\n///\n/// If there was not an entry in the dict for the given key then the function\n/// gets `None` as its argument, otherwise it gets `Some(value)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let dict = from_list([#(\"a\", 0)])\n/// let increment = fn(x) {\n///   case x {\n///     Some(i) -> i + 1\n///     None -> 0\n///   }\n/// }\n///\n/// upsert(dict, \"a\", increment)\n/// // -> from_list([#(\"a\", 1)])\n///\n/// upsert(dict, \"b\", increment)\n/// // -> from_list([#(\"a\", 0), #(\"b\", 0)])\n/// ```\n///\npub fn upsert(\n  in dict: Dict(k, v),\n  update key: k,\n  with fun: fn(Option(v)) -> v,\n) -> Dict(k, v) {\n  case get(dict, key) {\n    Ok(value) -> insert(dict, key, fun(option.Some(value)))\n    Error(_) -> insert(dict, key, fun(option.None))\n  }\n}\n\n/// Combines all entries into a single value by calling a given function on each\n/// one.\n///\n/// Dicts are not ordered so the values are not returned in any specific order. Do\n/// not write code that relies on the order entries are used by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let dict = from_list([#(\"a\", 1), #(\"b\", 3), #(\"c\", 9)])\n/// fold(dict, 0, fn(accumulator, key, value) { accumulator + value })\n/// // -> 13\n/// ```\n///\n/// ```gleam\n/// import gleam/string\n///\n/// let dict = from_list([#(\"a\", 1), #(\"b\", 3), #(\"c\", 9)])\n/// fold(dict, \"\", fn(accumulator, key, value) {\n///   string.append(accumulator, key)\n/// })\n/// // -> \"abc\"\n/// ```\n///\n@external(javascript, \"../dict.mjs\", \"fold\")\npub fn fold(\n  over dict: Dict(k, v),\n  from initial: acc,\n  with fun: fn(acc, k, v) -> acc,\n) -> acc {\n  let fun = fn(key, value, acc) { fun(acc, key, value) }\n  do_fold(fun, initial, dict)\n}\n\n@external(erlang, \"maps\", \"fold\")\nfn do_fold(fun: fn(k, v, acc) -> acc, initial: acc, dict: Dict(k, v)) -> acc\n\n/// Calls a function for each key and value in a dict, discarding the return\n/// value.\n///\n/// Useful for producing a side effect for every item of a dict.\n///\n/// ```gleam\n/// import gleam/io\n///\n/// let dict = from_list([#(\"a\", \"apple\"), #(\"b\", \"banana\"), #(\"c\", \"cherry\")])\n///\n/// each(dict, fn(k, v) {\n///   io.println(key <> \" => \" <> value)\n/// })\n/// // -> Nil\n/// // a => apple\n/// // b => banana\n/// // c => cherry\n/// ```\n///\n/// The order of elements in the iteration is an implementation detail that\n/// should not be relied upon.\n///\npub fn each(dict: Dict(k, v), fun: fn(k, v) -> a) -> Nil {\n  fold(dict, Nil, fn(nil, k, v) {\n    fun(k, v)\n    nil\n  })\n}\n\n/// Creates a new dict from a pair of given dicts by combining their entries.\n///\n/// If there are entries with the same keys in both dicts the given function is\n/// used to determine the new value to use in the resulting dict.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let a = from_list([#(\"a\", 0), #(\"b\", 1)])\n/// let b = from_list([#(\"a\", 2), #(\"c\", 3)])\n/// combine(a, b, fn(one, other) { one + other })\n/// // -> from_list([#(\"a\", 2), #(\"b\", 1), #(\"c\", 3)])\n/// ```\n///\npub fn combine(\n  dict: Dict(k, v),\n  other: Dict(k, v),\n  with fun: fn(v, v) -> v,\n) -> Dict(k, v) {\n  do_combine(fn(_, l, r) { fun(l, r) }, dict, other)\n}\n\n@external(erlang, \"maps\", \"merge_with\")\nfn do_combine(\n  combine: fn(k, v, v) -> v,\n  left: Dict(k, v),\n  right: Dict(k, v),\n) -> Dict(k, v) {\n  let #(big, small, combine) = case size(left) >= size(right) {\n    True -> #(left, right, combine)\n    False -> #(right, left, fn(k, l, r) { combine(k, r, l) })\n  }\n\n  to_transient(big)\n  |> fold(over: small, with: fn(transient, key, value) {\n    let update = fn(existing) { combine(key, existing, value) }\n    transient_update_with(key, update, value, transient)\n  })\n  |> from_transient\n}\n\n@external(erlang, \"maps\", \"update_with\")\n@external(javascript, \"../dict.mjs\", \"destructiveTransientUpdateWith\")\nfn transient_update_with(\n  key: k,\n  fun: fn(v) -> v,\n  init: v,\n  transient: TransientDict(k, v),\n) -> TransientDict(k, v)\n\n@internal\npub fn group(key: fn(v) -> k, list: List(v)) -> Dict(k, List(v)) {\n  group_loop(to_transient(new()), key, list)\n}\n\nfn group_loop(\n  transient: TransientDict(k, List(v)),\n  to_key: fn(v) -> k,\n  list: List(v),\n) -> Dict(k, List(v)) {\n  case list {\n    [] -> from_transient(transient)\n    [value, ..rest] -> {\n      let key = to_key(value)\n      let update = fn(existing) { [value, ..existing] }\n\n      transient\n      |> transient_update_with(key, update, [value], _)\n      |> group_loop(to_key, rest)\n    }\n  }\n}\n","gleam/dynamic/decode":"//// The `Dynamic` type is used to represent dynamically typed data. That is, data\n//// that we don't know the precise type of yet, so we need to introspect the data to\n//// see if it is of the desired type before we can use it. Typically data like this\n//// would come from user input or from untyped languages such as Erlang or JavaScript.\n////\n//// This module provides the `Decoder` type and associated functions, which provides\n//// a type-safe and composable way to convert dynamic data into some desired type,\n//// or into errors if the data doesn't have the desired structure.\n////\n//// The `Decoder` type is generic and has 1 type parameter, which is the type that\n//// it attempts to decode. A `Decoder(String)` can be used to decode strings, and a\n//// `Decoder(Option(Int))` can be used to decode `Option(Int)`s\n////\n//// Decoders work using _runtime reflection_ and the data structures of the target\n//// platform. Differences between Erlang and JavaScript data structures may impact\n//// your decoders, so it is important to test your decoders on all supported\n//// platforms.\n////\n//// The decoding technique used by this module was inspired by Juraj Petráš'\n//// [Toy](https://github.com/Hackder/toy), Go's `encoding/json`, and Elm's\n//// `Json.Decode`. Thank you to them!\n////\n//// # Examples\n////\n//// Dynamic data may come from various sources and so many different syntaxes could\n//// be used to describe or construct them. In these examples a pseudocode\n//// syntax is used to describe the data.\n////\n//// ## Simple types\n////\n//// This module defines decoders for simple data types such as [`string`](#string),\n//// [`int`](#int), [`float`](#float), [`bit_array`](#bit_array), and [`bool`](#bool).\n////\n//// ```gleam\n//// // Data:\n//// // \"Hello, Joe!\"\n////\n//// let result = decode.run(data, decode.string)\n//// assert result == Ok(\"Hello, Joe!\")\n//// ```\n////\n//// ## Lists\n////\n//// The [`list`](#list) decoder decodes `List`s. To use it you must construct it by\n//// passing in another decoder into the `list` function, which is the decoder that\n//// is to be used for the elements of the list, type checking both the list and its\n//// elements.\n////\n//// ```gleam\n//// // Data:\n//// // [1, 2, 3, 4]\n////\n//// let result = decode.run(data, decode.list(decode.int))\n//// assert result == Ok([1, 2, 3, 4])\n//// ```\n////\n//// On Erlang this decoder can decode from lists, and on JavaScript it can\n//// decode from lists as well as JavaScript arrays.\n////\n//// ## Options\n////\n//// The [`optional`](#optional) decoder is used to decode values that may or may not\n//// be present. In other environments these might be called \"nullable\" values.\n////\n//// Like the `list` decoder, the `optional` decoder takes another decoder,\n//// which is used to decode the value if it is present.\n////\n//// ```gleam\n//// // Data:\n//// // 12.45\n////\n//// let result = decode.run(data, decode.optional(decode.float))\n//// assert result == Ok(option.Some(12.45))\n//// ```\n//// ```gleam\n//// // Data:\n//// // null\n////\n//// let result = decode.run(data, decode.optional(decode.int))\n//// assert result == Ok(option.None)\n//// ```\n////\n//// This decoder knows how to handle multiple different runtime representations of\n//// absent values, including `Nil`, `None`, `null`, and `undefined`.\n////\n//// ## Dicts\n////\n//// The [`dict`](#dict) decoder decodes `Dicts` and contains two other decoders, one\n//// for the keys, one for the values.\n////\n//// ```gleam\n//// // Data:\n//// // { \"Lucy\" -> 10, \"Nubi\" -> 20 }\n////\n//// let result = decode.run(data, decode.dict(decode.string, decode.int))\n//// assert result == Ok(dict.from_list([\n////   #(\"Lucy\", 10),\n////   #(\"Nubi\", 20),\n//// ]))\n//// ```\n////\n//// ## Indexing objects\n////\n//// The [`at`](#at) decoder can be used to decode a value that is nested within\n//// key-value containers such as Gleam dicts, Erlang maps, or JavaScript objects.\n////\n//// ```gleam\n//// // Data:\n//// // { \"one\" -> { \"two\" -> 123 } }\n////\n//// let result = decode.run(data, decode.at([\"one\", \"two\"], decode.int))\n//// assert result == Ok(123)\n//// ```\n////\n//// ## Indexing arrays\n////\n//// If you use ints as keys then the [`at`](#at) decoder can be used to index into\n//// array-like containers such as Gleam or Erlang tuples, or JavaScript arrays.\n////\n//// ```gleam\n//// // Data:\n//// // [\"one\", \"two\", \"three\"]\n////\n//// let result = decode.run(data, decode.at([1], decode.string))\n//// assert result == Ok(\"two\")\n//// ```\n////\n//// ## Records\n////\n//// Decoding records from dynamic data is more complex and requires combining a\n//// decoder for each field and a special constructor that builds your records with\n//// the decoded field values.\n////\n//// ```gleam\n//// // Data:\n//// // {\n//// //   \"score\" -> 180,\n//// //   \"name\" -> \"Mel Smith\",\n//// //   \"is-admin\" -> false,\n//// //   \"enrolled\" -> true,\n//// //   \"colour\" -> \"Red\",\n//// // }\n////\n//// let decoder = {\n////   use name <- decode.field(\"name\", decode.string)\n////   use score <- decode.field(\"score\", decode.int)\n////   use colour <- decode.field(\"colour\", decode.string)\n////   use enrolled <- decode.field(\"enrolled\", decode.bool)\n////   decode.success(Player(name:, score:, colour:, enrolled:))\n//// }\n////\n//// let result = decode.run(data, decoder)\n//// assert result == Ok(Player(\"Mel Smith\", 180, \"Red\", True))\n//// ```\n////\n//// ## Enum variants\n////\n//// Imagine you have a custom type where all the variants do not contain any values.\n////\n//// ```gleam\n//// pub type PocketMonsterType {\n////   Fire\n////   Water\n////   Grass\n////   Electric\n//// }\n//// ```\n////\n//// You might choose to encode these variants as strings, `\"fire\"` for `Fire`,\n//// `\"water\"` for `Water`, and so on. To decode them you'll need to decode the dynamic\n//// data as a string, but then you'll need to decode it further still as not all\n//// strings are valid values for the enum. This can be done with the `then`\n//// function, which enables running a second decoder after the first one\n//// succeeds.\n////\n//// ```gleam\n//// let decoder = {\n////   use decoded_string <- decode.then(decode.string)\n////   case decoded_string {\n////     // Return succeeding decoders for valid strings\n////     \"fire\" -> decode.success(Fire)\n////     \"water\" -> decode.success(Water)\n////     \"grass\" -> decode.success(Grass)\n////     \"electric\" -> decode.success(Electric)\n////     // Return a failing decoder for any other strings\n////     _ -> decode.failure(Fire, expected: \"PocketMonsterType\")\n////   }\n//// }\n////\n//// let result = decode.run(dynamic.string(\"water\"), decoder)\n//// assert result == Ok(Water)\n////\n//// let result = decode.run(dynamic.string(\"wobble\"), decoder)\n//// assert result == Error([DecodeError(\"PocketMonsterType\", \"String\", [])])\n//// ```\n////\n//// ## Record variants\n////\n//// Decoding type variants that contain other values is done by combining the\n//// techniques from the \"enum variants\" and \"records\" examples. Imagine you have\n//// this custom type that you want to decode:\n////\n//// ```gleam\n//// pub type PocketMonsterPerson {\n////   Trainer(name: String, badge_count: Int)\n////   GymLeader(name: String, speciality: PocketMonsterType)\n//// }\n//// ```\n//// And you would like to be able to decode these from dynamic data like this:\n//// ```erlang\n//// {\n////   \"type\" -> \"trainer\",\n////   \"name\" -> \"Ash\",\n////   \"badge-count\" -> 1,\n//// }\n//// ```\n//// ```erlang\n//// {\n////   \"type\" -> \"gym-leader\",\n////   \"name\" -> \"Misty\",\n////   \"speciality\" -> \"water\",\n//// }\n//// ```\n////\n//// Notice how both documents have a `\"type\"` field, which is used to indicate which\n//// variant the data is for.\n////\n//// First, define decoders for each of the variants:\n////\n//// ```gleam\n//// let trainer_decoder = {\n////   use name <- decode.field(\"name\", decode.string)\n////   use badge_count <- decode.field(\"badge-count\", decode.int)\n////   decode.success(Trainer(name, badge_count))\n//// }\n////\n//// let gym_leader_decoder = {\n////   use name <- decode.field(\"name\", decode.string)\n////   use speciality <- decode.field(\"speciality\", pocket_monster_type_decoder)\n////   decode.success(GymLeader(name, speciality))\n//// }\n//// ```\n////\n//// A third decoder can be used to extract and decode the `\"type\"` field, and the\n//// expression can evaluate to whichever decoder is suitable for the document.\n////\n//// ```gleam\n//// // Data:\n//// // {\n//// //   \"type\" -> \"gym-leader\",\n//// //   \"name\" -> \"Misty\",\n//// //   \"speciality\" -> \"water\",\n//// // }\n////\n//// let decoder = {\n////   use tag <- decode.field(\"type\", decode.string)\n////   case tag {\n////     \"gym-leader\" -> gym_leader_decoder\n////     _ -> trainer_decoder\n////   }\n//// }\n////\n//// let result = decode.run(data, decoder)\n//// assert result == Ok(GymLeader(\"Misty\", Water))\n//// ```\n\nimport gleam/bit_array\nimport gleam/dict.{type Dict}\nimport gleam/dynamic\nimport gleam/int\nimport gleam/list\nimport gleam/option.{type Option, None, Some}\n\n/// `Dynamic` data is data that we don't know the type of yet, originating from\n/// external untyped systems.\n///\n/// You should never be converting your well typed data to dynamic data.\n///\npub type Dynamic =\n  dynamic.Dynamic\n\n/// Error returned when unexpected data is encountered\n///\npub type DecodeError {\n  DecodeError(expected: String, found: String, path: List(String))\n}\n\n/// A decoder is a value that can be used to turn dynamically typed `Dynamic`\n/// data into typed data using the `run` function.\n///\n/// Several smaller decoders can be combined to make larger decoders using\n/// functions such as `list` and `field`.\n///\npub opaque type Decoder(t) {\n  Decoder(function: fn(Dynamic) -> #(t, List(DecodeError)))\n}\n\n/// The same as [`field`](#field), except taking a path to the value rather\n/// than a field name.\n///\n/// This function will index into dictionaries with any key type, and if the key is\n/// an int then it'll also index into Erlang tuples and JavaScript arrays, and\n/// the first eight elements of Gleam lists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let data = dynamic.properties([\n///   #(dynamic.string(\"data\"), dynamic.properties([\n///     #(dynamic.string(\"email\"), dynamic.string(\"lucy@example.com\")),\n///     #(dynamic.string(\"name\"), dynamic.string(\"Lucy\")),\n///   ])\n/// ])\n///\n/// let decoder = {\n///   use name <- decode.subfield([\"data\", \"name\"], decode.string)\n///   use email <- decode.subfield([\"data\", \"email\"], decode.string)\n///   decode.success(SignUp(name: name, email: email))\n/// }\n/// let result = decode.run(data, decoder)\n/// assert result == Ok(SignUp(name: \"Lucy\", email: \"lucy@example.com\"))\n/// ```\n///\npub fn subfield(\n  field_path: List(name),\n  field_decoder: Decoder(t),\n  next: fn(t) -> Decoder(final),\n) -> Decoder(final) {\n  Decoder(function: fn(data) {\n    let #(out, errors1) =\n      index(field_path, [], field_decoder.function, data, fn(data, position) {\n        let #(default, _) = field_decoder.function(data)\n        #(default, [DecodeError(\"Field\", \"Nothing\", [])])\n        |> push_path(list.reverse(position))\n      })\n    let #(out, errors2) = next(out).function(data)\n    #(out, list.append(errors1, errors2))\n  })\n}\n\n/// Run a decoder on a `Dynamic` value, decoding the value if it is of the\n/// desired type, or returning errors.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let decoder = {\n///   use name <- decode.field(\"name\", decode.string)\n///   use email <- decode.field(\"email\", decode.string)\n///   decode.success(SignUp(name: name, email: email))\n/// }\n///\n/// decode.run(data, decoder)\n/// ```\n///\npub fn run(data: Dynamic, decoder: Decoder(t)) -> Result(t, List(DecodeError)) {\n  let #(maybe_invalid_data, errors) = decoder.function(data)\n  case errors {\n    [] -> Ok(maybe_invalid_data)\n    [_, ..] -> Error(errors)\n  }\n}\n\n/// A decoder that decodes a value that is nested within other values. For\n/// example, decoding a value that is within some deeply nested JSON objects.\n///\n/// This function will index into dictionaries with any key type, and if the key is\n/// an int then it'll also index into Erlang tuples and JavaScript arrays, and\n/// the first eight elements of Gleam lists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let decoder = decode.at([\"one\", \"two\"], decode.int)\n///\n/// let data = dynamic.properties([\n///   #(dynamic.string(\"one\"), dynamic.properties([\n///     #(dynamic.string(\"two\"), dynamic.int(1000)),\n///   ]),\n/// ])\n///\n/// decode.run(data, decoder)\n/// // -> Ok(1000)\n/// ```\n///\n/// ```gleam\n/// dynamic.nil()\n/// |> decode.run(decode.optional(decode.int))\n/// // -> Ok(option.None)\n/// ```\n///\npub fn at(path: List(segment), inner: Decoder(a)) -> Decoder(a) {\n  Decoder(function: fn(data) {\n    index(path, [], inner.function, data, fn(data, position) {\n      let #(default, _) = inner.function(data)\n      #(default, [DecodeError(\"Field\", \"Nothing\", [])])\n      |> push_path(list.reverse(position))\n    })\n  })\n}\n\nfn index(\n  path: List(a),\n  position: List(a),\n  inner: fn(Dynamic) -> #(b, List(DecodeError)),\n  data: Dynamic,\n  handle_miss: fn(Dynamic, List(a)) -> #(b, List(DecodeError)),\n) -> #(b, List(DecodeError)) {\n  case path {\n    [] -> {\n      data\n      |> inner\n      |> push_path(list.reverse(position))\n    }\n\n    [key, ..path] -> {\n      case bare_index(data, key) {\n        Ok(Some(data)) -> {\n          index(path, [key, ..position], inner, data, handle_miss)\n        }\n        Ok(None) -> {\n          handle_miss(data, [key, ..position])\n        }\n        Error(kind) -> {\n          let #(default, _) = inner(data)\n          #(default, [DecodeError(kind, dynamic.classify(data), [])])\n          |> push_path(list.reverse(position))\n        }\n      }\n    }\n  }\n}\n\n@external(erlang, \"gleam_stdlib\", \"index\")\n@external(javascript, \"../../gleam_stdlib.mjs\", \"index\")\nfn bare_index(data: Dynamic, key: anything) -> Result(Option(Dynamic), String)\n\nfn push_path(\n  layer: #(t, List(DecodeError)),\n  path: List(key),\n) -> #(t, List(DecodeError)) {\n  let decoder = one_of(string, [int |> map(int.to_string)])\n  let path =\n    list.map(path, fn(key) {\n      let key = cast(key)\n      case run(key, decoder) {\n        Ok(key) -> key\n        Error(_) -> \"<\" <> dynamic.classify(key) <> \">\"\n      }\n    })\n  let errors =\n    list.map(layer.1, fn(error) {\n      DecodeError(..error, path: list.append(path, error.path))\n    })\n  #(layer.0, errors)\n}\n\n/// Finalise a decoder having successfully extracted a value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let data = dynamic.properties([\n///   #(dynamic.string(\"email\"), dynamic.string(\"lucy@example.com\")),\n///   #(dynamic.string(\"name\"), dynamic.string(\"Lucy\")),\n/// ])\n///\n/// let decoder = {\n///   use name <- decode.field(\"name\", string)\n///   use email <- decode.field(\"email\", string)\n///   decode.success(SignUp(name: name, email: email))\n/// }\n///\n/// let result = decode.run(data, decoder)\n/// assert result == Ok(SignUp(name: \"Lucy\", email: \"lucy@example.com\"))\n/// ```\n///\npub fn success(data: t) -> Decoder(t) {\n  Decoder(function: fn(_) { #(data, []) })\n}\n\n/// Construct a decode error for some unexpected dynamic data.\n///\npub fn decode_error(\n  expected expected: String,\n  found found: Dynamic,\n) -> List(DecodeError) {\n  [DecodeError(expected: expected, found: dynamic.classify(found), path: [])]\n}\n\n/// Run a decoder on a field of a `Dynamic` value, decoding the value if it is\n/// of the desired type, or returning errors. An error is returned if there is\n/// no field for the specified key.\n///\n/// This function will index into dictionaries with any key type, and if the key is\n/// an int then it'll also index into Erlang tuples and JavaScript arrays, and\n/// the first eight elements of Gleam lists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let data = dynamic.properties([\n///   #(dynamic.string(\"email\"), dynamic.string(\"lucy@example.com\")),\n///   #(dynamic.string(\"name\"), dynamic.string(\"Lucy\")),\n/// ])\n///\n/// let decoder = {\n///   use name <- decode.field(\"name\", string)\n///   use email <- decode.field(\"email\", string)\n///   decode.success(SignUp(name: name, email: email))\n/// }\n///\n/// let result = decode.run(data, decoder)\n/// assert result == Ok(SignUp(name: \"Lucy\", email: \"lucy@example.com\"))\n/// ```\n///\n/// If you wish to decode a value that is more deeply nested within the dynamic\n/// data, see [`subfield`](#subfield) and [`at`](#at).\n///\n/// If you wish to return a default in the event that a field is not present,\n/// see [`optional_field`](#optional_field) and / [`optionally_at`](#optionally_at).\n///\npub fn field(\n  field_name: name,\n  field_decoder: Decoder(t),\n  next: fn(t) -> Decoder(final),\n) -> Decoder(final) {\n  subfield([field_name], field_decoder, next)\n}\n\n/// Run a decoder on a field of a `Dynamic` value, decoding the value if it is\n/// of the desired type, or returning errors. The given default value is\n/// returned if there is no field for the specified key.\n///\n/// This function will index into dictionaries with any key type, and if the key is\n/// an int then it'll also index into Erlang tuples and JavaScript arrays, and\n/// the first eight elements of Gleam lists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let data = dynamic.properties([\n///   #(dynamic.string(\"name\"), dynamic.string(\"Lucy\")),\n/// ])\n///\n/// let decoder = {\n///   use name <- decode.field(\"name\", string)\n///   use email <- decode.optional_field(\"email\", \"n/a\", string)\n///   decode.success(SignUp(name: name, email: email))\n/// }\n///\n/// let result = decode.run(data, decoder)\n/// assert result == Ok(SignUp(name: \"Lucy\", email: \"n/a\"))\n/// ```\n///\npub fn optional_field(\n  key: name,\n  default: t,\n  field_decoder: Decoder(t),\n  next: fn(t) -> Decoder(final),\n) -> Decoder(final) {\n  Decoder(function: fn(data) {\n    let #(out, errors1) =\n      case bare_index(data, key) {\n        Ok(Some(data)) -> field_decoder.function(data)\n        Ok(None) -> #(default, [])\n        Error(kind) -> #(default, [\n          DecodeError(kind, dynamic.classify(data), []),\n        ])\n      }\n      |> push_path([key])\n    let #(out, errors2) = next(out).function(data)\n    #(out, list.append(errors1, errors2))\n  })\n}\n\n/// A decoder that decodes a value that is nested within other values. For\n/// example, decoding a value that is within some deeply nested JSON objects.\n///\n/// This function will index into dictionaries with any key type, and if the key is\n/// an int then it'll also index into Erlang tuples and JavaScript arrays, and\n/// the first eight elements of Gleam lists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let decoder = decode.optionally_at([\"one\", \"two\"], 100, decode.int)\n///\n/// let data = dynamic.properties([\n///   #(dynamic.string(\"one\"), dynamic.properties([])),\n/// ])\n///\n/// decode.run(data, decoder)\n/// // -> Ok(100)\n/// ```\n///\npub fn optionally_at(\n  path: List(segment),\n  default: a,\n  inner: Decoder(a),\n) -> Decoder(a) {\n  Decoder(function: fn(data) {\n    index(path, [], inner.function, data, fn(_, _) { #(default, []) })\n  })\n}\n\nfn run_dynamic_function(\n  data: Dynamic,\n  name: String,\n  f: fn(Dynamic) -> Result(t, t),\n) -> #(t, List(DecodeError)) {\n  case f(data) {\n    Ok(data) -> #(data, [])\n    Error(placeholder) -> #(placeholder, [\n      DecodeError(name, dynamic.classify(data), []),\n    ])\n  }\n}\n\n/// A decoder that decodes `String` values.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let result = decode.run(dynamic.string(\"Hello!\"), decode.string)\n/// assert result == Ok(\"Hello!\")\n/// ```\n///\npub const string: Decoder(String) = Decoder(decode_string)\n\nfn decode_string(data: Dynamic) -> #(String, List(DecodeError)) {\n  run_dynamic_function(data, \"String\", dynamic_string)\n}\n\n@external(javascript, \"../../gleam_stdlib.mjs\", \"string\")\nfn dynamic_string(from data: Dynamic) -> Result(String, String) {\n  case dynamic_bit_array(data) {\n    Ok(data) ->\n      case bit_array.to_string(data) {\n        Ok(string) -> Ok(string)\n        Error(_) -> Error(\"\")\n      }\n    Error(_) -> Error(\"\")\n  }\n}\n\n/// A decoder that decodes `Bool` values.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let result = decode.run(dynamic.bool(True), decode.bool)\n/// assert result == Ok(True)\n/// ```\n///\npub const bool: Decoder(Bool) = Decoder(decode_bool)\n\nfn decode_bool(data: Dynamic) -> #(Bool, List(DecodeError)) {\n  case cast(True) == data {\n    True -> #(True, [])\n    False ->\n      case cast(False) == data {\n        True -> #(False, [])\n        False -> #(False, decode_error(\"Bool\", data))\n      }\n  }\n}\n\n/// A decoder that decodes `Int` values.\n///\n/// This will not coerse float values into int values, so on platforms with\n/// distinct runtime int and float types (Erlang, not JavaScript) it will fail,\n/// even if the float is a whole number (e.g. 1.0).\n///\n/// If you want to decode both ints and floats you may want to use the `one_of`\n/// function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let result = decode.run(dynamic.int(147), decode.int)\n/// assert result == Ok(147)\n/// ```\n///\npub const int: Decoder(Int) = Decoder(decode_int)\n\nfn decode_int(data: Dynamic) -> #(Int, List(DecodeError)) {\n  run_dynamic_function(data, \"Int\", dynamic_int)\n}\n\n@external(erlang, \"gleam_stdlib\", \"int\")\n@external(javascript, \"../../gleam_stdlib.mjs\", \"int\")\nfn dynamic_int(data: Dynamic) -> Result(Int, Int)\n\n/// A decoder that decodes `Float` values.\n///\n/// This will not coerse int values into float values, so on platforms with\n/// distinct runtime int and float types (Erlang, not JavaScript) it will fail\n/// for ints. One time this may happen is when decoding JSON data.\n///\n/// If you want to decode both ints and floats you may want to use the `one_of`\n/// function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let result = decode.run(dynamic.float(3.14), decode.float)\n/// assert result == Ok(3.14)\n/// ```\n///\npub const float: Decoder(Float) = Decoder(decode_float)\n\nfn decode_float(data: Dynamic) -> #(Float, List(DecodeError)) {\n  run_dynamic_function(data, \"Float\", dynamic_float)\n}\n\n@external(erlang, \"gleam_stdlib\", \"float\")\n@external(javascript, \"../../gleam_stdlib.mjs\", \"float\")\nfn dynamic_float(data: Dynamic) -> Result(Float, Float)\n\n/// A decoder that decodes `Dynamic` values. This decoder never returns an error.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let result = decode.run(dynamic.float(3.14), decode.dynamic)\n/// assert result == Ok(dynamic.float(3.14))\n/// ```\n///\npub const dynamic: Decoder(Dynamic) = Decoder(decode_dynamic)\n\nfn decode_dynamic(data: Dynamic) -> #(Dynamic, List(DecodeError)) {\n  #(data, [])\n}\n\n/// A decoder that decodes `BitArray` values. This decoder never returns an error.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let result = decode.run(dynamic.bit_array(<<5, 7>>), decode.bit_array)\n/// assert result == Ok(<<5, 7>>)\n/// ```\n///\npub const bit_array: Decoder(BitArray) = Decoder(decode_bit_array)\n\nfn decode_bit_array(data: Dynamic) -> #(BitArray, List(DecodeError)) {\n  run_dynamic_function(data, \"BitArray\", dynamic_bit_array)\n}\n\n@external(erlang, \"gleam_stdlib\", \"bit_array\")\n@external(javascript, \"../../gleam_stdlib.mjs\", \"bit_array\")\nfn dynamic_bit_array(data: Dynamic) -> Result(BitArray, BitArray)\n\n/// A decoder that decodes lists where all elements are decoded with a given\n/// decoder.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let result =\n///   [1, 2, 3]\n///   |> list.map(dynamic.int)\n///   |> dynamic.list\n///   |> decode.run(decode.list(of: decode.int))\n/// assert result == Ok([1, 2, 3])\n/// ```\n///\npub fn list(of inner: Decoder(a)) -> Decoder(List(a)) {\n  Decoder(fn(data) {\n    decode_list(data, inner.function, fn(p, k) { push_path(p, [k]) }, 0, [])\n  })\n}\n\n@external(erlang, \"gleam_stdlib\", \"list\")\n@external(javascript, \"../../gleam_stdlib.mjs\", \"list\")\nfn decode_list(\n  data: Dynamic,\n  item: fn(Dynamic) -> #(t, List(DecodeError)),\n  push_path: fn(#(t, List(DecodeError)), key) -> #(t, List(DecodeError)),\n  index: Int,\n  acc: List(t),\n) -> #(List(t), List(DecodeError))\n\n/// A decoder that decodes dicts where all keys and values are decoded with\n/// given decoders.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let values = dynamic.properties([\n///   #(dynamic.string(\"one\"), dynamic.int(1)),\n///   #(dynamic.string(\"two\"), dynamic.int(2)),\n/// ])\n///\n/// let result =\n///   decode.run(values, decode.dict(decode.string, decode.int))\n/// assert result == Ok(values)\n/// ```\n///\npub fn dict(\n  key: Decoder(key),\n  value: Decoder(value),\n) -> Decoder(Dict(key, value)) {\n  Decoder(fn(data) {\n    case decode_dict(data) {\n      Error(_) -> #(dict.new(), decode_error(\"Dict\", data))\n      Ok(dict) ->\n        dict.fold(dict, #(dict.new(), []), fn(a, k, v) {\n          // If there are any errors from previous key-value pairs then we\n          // don't need to run the decoders, instead return the existing acc.\n          case a.1 {\n            [] -> fold_dict(a, k, v, key.function, value.function)\n            [_, ..] -> a\n          }\n        })\n    }\n  })\n}\n\nfn fold_dict(\n  acc: #(Dict(k, v), List(DecodeError)),\n  key: Dynamic,\n  value: Dynamic,\n  key_decoder: fn(Dynamic) -> #(k, List(DecodeError)),\n  value_decoder: fn(Dynamic) -> #(v, List(DecodeError)),\n) -> #(Dict(k, v), List(DecodeError)) {\n  // First we decode the key.\n  case key_decoder(key) {\n    #(key, []) ->\n      // Then we decode the value.\n      case value_decoder(value) {\n        #(value, []) -> {\n          // It worked! Insert the new key-value pair so we can move onto the next.\n          let dict = dict.insert(acc.0, key, value)\n          #(dict, acc.1)\n        }\n        #(_, errors) -> push_path(#(dict.new(), errors), [\"values\"])\n      }\n    #(_, errors) -> push_path(#(dict.new(), errors), [\"keys\"])\n  }\n}\n\n@external(erlang, \"gleam_stdlib\", \"dict\")\n@external(javascript, \"../../gleam_stdlib.mjs\", \"dict\")\nfn decode_dict(data: Dynamic) -> Result(Dict(Dynamic, Dynamic), Nil)\n\n/// A decoder that decodes nullable values of a type decoded by with a given\n/// decoder.\n///\n/// This function can handle common representations of null on all runtimes, such as\n/// `nil`, `null`, and `undefined` on Erlang, and `undefined` and `null` on\n/// JavaScript.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let result = decode.run(dynamic.int(100), decode.optional(decode.int))\n/// assert result == Ok(option.Some(100))\n/// ```\n///\n/// ```gleam\n/// let result = decode.run(dynamic.nil(), decode.optional(decode.int))\n/// assert result == Ok(option.None)\n/// ```\n///\npub fn optional(inner: Decoder(a)) -> Decoder(Option(a)) {\n  Decoder(function: fn(data) {\n    case is_null(data) {\n      True -> #(option.None, [])\n      False -> {\n        let #(data, errors) = inner.function(data)\n        #(option.Some(data), errors)\n      }\n    }\n  })\n}\n\n/// Apply a transformation function to any value decoded by the decoder.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let decoder = decode.int |> decode.map(int.to_string)\n/// let result = decode.run(dynamic.int(1000), decoder)\n/// assert result == Ok(\"1000\")\n/// ```\n///\npub fn map(decoder: Decoder(a), transformer: fn(a) -> b) -> Decoder(b) {\n  Decoder(function: fn(d) {\n    let #(data, errors) = decoder.function(d)\n    #(transformer(data), errors)\n  })\n}\n\n/// Apply a transformation function to any errors returned by the decoder.\n///\npub fn map_errors(\n  decoder: Decoder(a),\n  transformer: fn(List(DecodeError)) -> List(DecodeError),\n) -> Decoder(a) {\n  Decoder(function: fn(d) {\n    let #(data, errors) = decoder.function(d)\n    #(data, transformer(errors))\n  })\n}\n\n/// Replace all errors produced by a decoder with one single error for a named\n/// expected type.\n///\n/// This function may be useful if you wish to simplify errors before\n/// presenting them to a user, particularly when using the `one_of` function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let decoder = decode.string |> decode.collapse_errors(\"MyThing\")\n/// let result = decode.run(dynamic.int(1000), decoder)\n/// assert result == Error([DecodeError(\"MyThing\", \"Int\", [])])\n/// ```\n///\npub fn collapse_errors(decoder: Decoder(a), name: String) -> Decoder(a) {\n  Decoder(function: fn(dynamic_data) {\n    let #(data, errors) as layer = decoder.function(dynamic_data)\n    case errors {\n      [] -> layer\n      [_, ..] -> #(data, decode_error(name, dynamic_data))\n    }\n  })\n}\n\n/// Create a new decoder based upon the value of a previous decoder.\n///\n/// This may be useful to run one previous decoder to use in further decoding.\n///\npub fn then(decoder: Decoder(a), next: fn(a) -> Decoder(b)) -> Decoder(b) {\n  Decoder(function: fn(dynamic_data) {\n    let #(data, errors) = decoder.function(dynamic_data)\n    let decoder = next(data)\n    let #(data, _) as layer = decoder.function(dynamic_data)\n    case errors {\n      [] -> layer\n      [_, ..] -> #(data, errors)\n    }\n  })\n}\n\n/// Create a new decoder from several other decoders. Each of the inner\n/// decoders is run in turn, and the value from the first to succeed is used.\n///\n/// If no decoder succeeds then the errors from the first decoder are used.\n/// If you wish for different errors then you may wish to use the\n/// `collapse_errors` or `map_errors` functions.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let decoder = decode.one_of(decode.string, or: [\n///   decode.int |> decode.map(int.to_string),\n///   decode.float |> decode.map(float.to_string),\n/// ])\n/// decode.run(dynamic.int(1000), decoder)\n/// // -> Ok(\"1000\")\n/// ```\n///\npub fn one_of(\n  first: Decoder(a),\n  or alternatives: List(Decoder(a)),\n) -> Decoder(a) {\n  Decoder(function: fn(dynamic_data) {\n    let #(_, errors) as layer = first.function(dynamic_data)\n    case errors {\n      [] -> layer\n      [_, ..] -> run_decoders(dynamic_data, layer, alternatives)\n    }\n  })\n}\n\nfn run_decoders(\n  data: Dynamic,\n  failure: #(a, List(DecodeError)),\n  decoders: List(Decoder(a)),\n) -> #(a, List(DecodeError)) {\n  case decoders {\n    [] -> failure\n\n    [decoder, ..decoders] -> {\n      let #(_, errors) as layer = decoder.function(data)\n      case errors {\n        [] -> layer\n        [_, ..] -> run_decoders(data, failure, decoders)\n      }\n    }\n  }\n}\n\n/// Define a decoder that always fails.\n///\n/// The first parameter is a \"placeholder\" value, which is some default value that the\n/// decoder uses internally in place of the value that would have been produced\n/// if the decoder was successful. It doesn't matter what this value is, it is\n/// never returned by the decoder or shown to the user, so pick some arbitrary\n/// value. If it is an int you might pick `0`, if it is a list you might pick\n/// `[]`.\n///\n/// The second parameter is the name of the type that has failed to decode.\n///\n/// ```gleam\n/// decode.failure(User(name: \"\", score: 0, tags: []), expected: \"User\")\n/// ```\n///\npub fn failure(placeholder: a, expected name: String) -> Decoder(a) {\n  Decoder(function: fn(d) { #(placeholder, decode_error(name, d)) })\n}\n\n/// Create a decoder for a new data type from a decoding function.\n///\n/// This function is used for new primitive types. For example, you might\n/// define a decoder for Erlang's pid type.\n///\n/// A default \"placeholder\" value is also required to make a decoder. When this\n/// decoder is used as part of a larger decoder this placeholder value is used\n/// so that the rest of the decoder can continue to run and\n/// collect all decoding errors. It doesn't matter what this value is, it is\n/// never returned by the decoder or shown to the user, so pick some arbitrary\n/// value. If it is an int you might pick `0`, if it is a list you might pick\n/// `[]`.\n///\n/// If you were to make a decoder for the `Int` type (rather than using the\n/// build-in `Int` decoder) you would define it like so:\n///\n/// ```gleam\n/// pub fn int_decoder() -> decode.Decoder(Int) {\n///   let default = \"\"\n///   decode.new_primitive_decoder(\"Int\", int_from_dynamic)\n/// }\n///\n/// @external(erlang, \"my_module\", \"int_from_dynamic\")\n/// fn int_from_dynamic(data: Int) -> Result(Int, Int)\n/// ```\n///\n/// ```erlang\n/// -module(my_module).\n/// -export([int_from_dynamic/1]).\n///\n/// int_from_dynamic(Data) ->\n///     case is_integer(Data) of\n///         true -> {ok, Data};\n///         false -> {error, 0}\n///     end.\n/// ```\n///\npub fn new_primitive_decoder(\n  name: String,\n  decoding_function: fn(Dynamic) -> Result(t, t),\n) -> Decoder(t) {\n  Decoder(function: fn(d) {\n    case decoding_function(d) {\n      Ok(t) -> #(t, [])\n      Error(placeholder) -> #(placeholder, [\n        DecodeError(name, dynamic.classify(d), []),\n      ])\n    }\n  })\n}\n\n/// Create a decoder that can refer to itself, useful for decoding deeply\n/// nested data.\n///\n/// Attempting to create a recursive decoder without this function could result\n/// in an infinite loop. If you are using `field` or other `use`able functions\n/// then you may not need to use this function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// type Nested {\n///   Nested(List(Nested))\n///   Value(String)\n/// }\n///\n/// fn nested_decoder() -> decode.Decoder(Nested) {\n///   use <- decode.recursive\n///   decode.one_of(decode.string |> decode.map(Value), [\n///     decode.list(nested_decoder()) |> decode.map(Nested),\n///   ])\n/// }\n/// ```\n///\npub fn recursive(inner: fn() -> Decoder(a)) -> Decoder(a) {\n  Decoder(function: fn(data) {\n    let decoder = inner()\n    decoder.function(data)\n  })\n}\n\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../../gleam_stdlib.mjs\", \"identity\")\nfn cast(a: anything) -> Dynamic\n\n@external(erlang, \"gleam_stdlib\", \"is_null\")\n@external(javascript, \"../../gleam_stdlib.mjs\", \"is_null\")\nfn is_null(a: Dynamic) -> Bool\n","gleam/dynamic":"import gleam/dict\n\n/// `Dynamic` data is data that we don't know the type of yet.\n/// We likely get data like this from interop with Erlang, or from\n/// IO with the outside world.\n///\n/// This module contains code for forming dynamic data, and the\n/// `gleam/dynamic/decode` module contains code for turning dynamic data back\n/// into Gleam data with known types. You will likely mostly use the other\n/// module in your projects.\n///\n/// The exact runtime representation of dynamic values will depend on the\n/// compilation target used.\n///\npub type Dynamic\n\n/// Return a string indicating the type of the dynamic value.\n///\n/// This function may be useful for constructing error messages or logs. If you\n/// want to turn dynamic data into well typed data then you want the\n/// `gleam/dynamic/decode` module.\n///\n/// ```gleam\n/// classify(string(\"Hello\"))\n/// // -> \"String\"\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"classify_dynamic\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"classify_dynamic\")\npub fn classify(data: Dynamic) -> String\n\n/// Create a dynamic value from a bool.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn bool(a: Bool) -> Dynamic\n\n/// Create a dynamic value from a string.\n///\n/// On Erlang this will be a binary string rather than a character list.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn string(a: String) -> Dynamic\n\n/// Create a dynamic value from a float.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn float(a: Float) -> Dynamic\n\n/// Create a dynamic value from an int.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn int(a: Int) -> Dynamic\n\n/// Create a dynamic value from a bit array.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn bit_array(a: BitArray) -> Dynamic\n\n/// Create a dynamic value from a list.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn list(a: List(Dynamic)) -> Dynamic\n\n/// Create a dynamic value from a list, converting it to a sequential runtime\n/// format rather than the regular list format.\n///\n/// On Erlang this will be a tuple, on JavaScript this will be an array.\n///\n@external(erlang, \"erlang\", \"list_to_tuple\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"list_to_array\")\npub fn array(a: List(Dynamic)) -> Dynamic\n\n/// Create a dynamic value made of an unordered series of keys and values, where\n/// the keys are unique.\n///\n/// On Erlang this will be a map, on JavaScript this will be a Gleam dict\n/// object.\n///\npub fn properties(entries: List(#(Dynamic, Dynamic))) -> Dynamic {\n  cast(dict.from_list(entries))\n}\n\n/// A dynamic value representing nothing.\n///\n/// On Erlang this will be the atom `nil`, on JavaScript this will be\n/// `undefined`.\n///\npub fn nil() -> Dynamic {\n  cast(Nil)\n}\n\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\nfn cast(a: anything) -> Dynamic\n","gleam/float":"//// Functions for working with floats.\n////\n//// ## Float representation\n////\n//// Floats are represented as 64 bit floating point numbers on both the Erlang\n//// and JavaScript runtimes. The floating point behaviour is native to their\n//// respective runtimes, so their exact behaviour will be slightly different on\n//// the two runtimes.\n////\n//// ### Infinity and NaN\n////\n//// Under the JavaScript runtime, exceeding the maximum (or minimum)\n//// representable value for a floating point value will result in Infinity (or\n//// -Infinity). Should you try to divide two infinities you will get NaN as a\n//// result.\n////\n//// When running on BEAM, exceeding the maximum (or minimum) representable\n//// value for a floating point value will raise an error.\n////\n//// ## Division by zero\n////\n//// Gleam runs on the Erlang virtual machine, which does not follow the IEEE\n//// 754 standard for floating point arithmetic and does not have an `Infinity`\n//// value.  In Erlang division by zero results in a crash, however Gleam does\n//// not have partial functions and operators in core so instead division by zero\n//// returns zero, a behaviour taken from Pony, Coq, and Lean.\n////\n//// This may seem unexpected at first, but it is no less mathematically valid\n//// than crashing or returning a special value. Division by zero is undefined\n//// in mathematics.\n\nimport gleam/order.{type Order}\n\n/// Attempts to parse a string as a `Float`, returning `Error(Nil)` if it was\n/// not possible.\n///\n/// ## Examples\n///\n/// ```gleam\n/// parse(\"2.3\")\n/// // -> Ok(2.3)\n/// ```\n///\n/// ```gleam\n/// parse(\"ABC\")\n/// // -> Error(Nil)\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"parse_float\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"parse_float\")\npub fn parse(string: String) -> Result(Float, Nil)\n\n/// Returns the string representation of the provided `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_string(2.3)\n/// // -> \"2.3\"\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"float_to_string\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"float_to_string\")\npub fn to_string(x: Float) -> String\n\n/// Restricts a float between two bounds.\n///\n/// Note: If the `min` argument is larger than the `max` argument then they\n/// will be swapped, so the minimum bound is always lower than the maximum\n/// bound.\n///\n///\n/// ## Examples\n///\n/// ```gleam\n/// clamp(1.2, min: 1.4, max: 1.6)\n/// // -> 1.4\n/// ```\n///\n/// ```gleam\n/// clamp(1.2, min: 1.4, max: 0.6)\n/// // -> 1.2\n/// ```\n///\npub fn clamp(x: Float, min min_bound: Float, max max_bound: Float) -> Float {\n  case min_bound >=. max_bound {\n    True -> x |> min(min_bound) |> max(max_bound)\n    False -> x |> min(max_bound) |> max(min_bound)\n  }\n}\n\n/// Compares two `Float`s, returning an `Order`:\n/// `Lt` for lower than, `Eq` for equals, or `Gt` for greater than.\n///\n/// ## Examples\n///\n/// ```gleam\n/// compare(2.0, 2.3)\n/// // -> Lt\n/// ```\n///\n/// To handle\n/// [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems)\n/// you may use [`loosely_compare`](#loosely_compare) instead.\n///\npub fn compare(a: Float, with b: Float) -> Order {\n  case a == b {\n    True -> order.Eq\n    False ->\n      case a <. b {\n        True -> order.Lt\n        False -> order.Gt\n      }\n  }\n}\n\n/// Compares two `Float`s within a tolerance, returning an `Order`:\n/// `Lt` for lower than, `Eq` for equals, or `Gt` for greater than.\n///\n/// This function allows Float comparison while handling\n/// [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems).\n///\n/// Notice: For `Float`s the tolerance won't be exact:\n/// `5.3 - 5.0` is not exactly `0.3`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// loosely_compare(5.0, with: 5.3, tolerating: 0.5)\n/// // -> Eq\n/// ```\n///\n/// If you want to check only for equality you may use\n/// [`loosely_equals`](#loosely_equals) instead.\n///\npub fn loosely_compare(\n  a: Float,\n  with b: Float,\n  tolerating tolerance: Float,\n) -> Order {\n  let difference = absolute_value(a -. b)\n  case difference <=. tolerance {\n    True -> order.Eq\n    False -> compare(a, b)\n  }\n}\n\n/// Checks for equality of two `Float`s within a tolerance,\n/// returning a `Bool`.\n///\n/// This function allows Float comparison while handling\n/// [Floating Point Imprecision](https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems).\n///\n/// Notice: For `Float`s the tolerance won't be exact:\n/// `5.3 - 5.0` is not exactly `0.3`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// loosely_equals(5.0, with: 5.3, tolerating: 0.5)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// loosely_equals(5.0, with: 5.1, tolerating: 0.1)\n/// // -> False\n/// ```\n///\npub fn loosely_equals(\n  a: Float,\n  with b: Float,\n  tolerating tolerance: Float,\n) -> Bool {\n  let difference = absolute_value(a -. b)\n  difference <=. tolerance\n}\n\n/// Compares two `Float`s, returning the smaller of the two.\n///\n/// ## Examples\n///\n/// ```gleam\n/// min(2.0, 2.3)\n/// // -> 2.0\n/// ```\n///\npub fn min(a: Float, b: Float) -> Float {\n  case a <. b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Compares two `Float`s, returning the larger of the two.\n///\n/// ## Examples\n///\n/// ```gleam\n/// max(2.0, 2.3)\n/// // -> 2.3\n/// ```\n///\npub fn max(a: Float, b: Float) -> Float {\n  case a >. b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Rounds the value to the next highest whole number as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// ceiling(2.3)\n/// // -> 3.0\n/// ```\n///\n@external(erlang, \"math\", \"ceil\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"ceiling\")\npub fn ceiling(x: Float) -> Float\n\n/// Rounds the value to the next lowest whole number as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// floor(2.3)\n/// // -> 2.0\n/// ```\n///\n@external(erlang, \"math\", \"floor\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"floor\")\npub fn floor(x: Float) -> Float\n\n/// Rounds the value to the nearest whole number as an `Int`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// round(2.3)\n/// // -> 2\n/// ```\n///\n/// ```gleam\n/// round(2.5)\n/// // -> 3\n/// ```\n///\n@external(erlang, \"erlang\", \"round\")\npub fn round(x: Float) -> Int {\n  case x >=. 0.0 {\n    True -> js_round(x)\n    False -> 0 - js_round(negate(x))\n  }\n}\n\n@external(javascript, \"../gleam_stdlib.mjs\", \"round\")\nfn js_round(a: Float) -> Int\n\n/// Returns the value as an `Int`, truncating all decimal digits.\n///\n/// ## Examples\n///\n/// ```gleam\n/// truncate(2.4343434847383438)\n/// // -> 2\n/// ```\n///\n@external(erlang, \"erlang\", \"trunc\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"truncate\")\npub fn truncate(x: Float) -> Int\n\n/// Converts the value to a given precision as a `Float`.\n/// The precision is the number of allowed decimal places.\n/// Negative precisions are allowed and force rounding\n/// to the nearest tenth, hundredth, thousandth etc.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_precision(2.43434348473, 2)\n/// // -> 2.43\n/// ```\n///\n/// ```gleam\n/// to_precision(547890.453444, -3)\n/// // -> 548000.0\n/// ```\n///\npub fn to_precision(x: Float, precision: Int) -> Float {\n  case precision <= 0 {\n    True -> {\n      let factor = do_power(10.0, do_to_float(-precision))\n      do_to_float(round(x /. factor)) *. factor\n    }\n    False -> {\n      let factor = do_power(10.0, do_to_float(precision))\n      do_to_float(round(x *. factor)) /. factor\n    }\n  }\n}\n\n@external(erlang, \"erlang\", \"float\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\nfn do_to_float(a: Int) -> Float\n\n/// Returns the absolute value of the input as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// absolute_value(-12.5)\n/// // -> 12.5\n/// ```\n///\n/// ```gleam\n/// absolute_value(10.2)\n/// // -> 10.2\n/// ```\n///\npub fn absolute_value(x: Float) -> Float {\n  case x >=. 0.0 {\n    True -> x\n    False -> 0.0 -. x\n  }\n}\n\n/// Returns the result of the base being raised to the power of the\n/// exponent, as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// power(2.0, -1.0)\n/// // -> Ok(0.5)\n/// ```\n///\n/// ```gleam\n/// power(2.0, 2.0)\n/// // -> Ok(4.0)\n/// ```\n///\n/// ```gleam\n/// power(8.0, 1.5)\n/// // -> Ok(22.627416997969522)\n/// ```\n///\n/// ```gleam\n/// 4.0 |> power(of: 2.0)\n/// // -> Ok(16.0)\n/// ```\n///\n/// ```gleam\n/// power(-1.0, 0.5)\n/// // -> Error(Nil)\n/// ```\n///\npub fn power(base: Float, of exponent: Float) -> Result(Float, Nil) {\n  let fractional: Bool = ceiling(exponent) -. exponent >. 0.0\n  // In the following check:\n  // 1. If the base is negative and the exponent is fractional then\n  //    return an error as it will otherwise be an imaginary number\n  // 2. If the base is 0 and the exponent is negative then the expression\n  //    is equivalent to the exponent divided by 0 and an error should be\n  //    returned\n  case base <. 0.0 && fractional || base == 0.0 && exponent <. 0.0 {\n    True -> Error(Nil)\n    False -> Ok(do_power(base, exponent))\n  }\n}\n\n@external(erlang, \"math\", \"pow\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"power\")\nfn do_power(a: Float, b: Float) -> Float\n\n/// Returns the square root of the input as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// square_root(4.0)\n/// // -> Ok(2.0)\n/// ```\n///\n/// ```gleam\n/// square_root(-16.0)\n/// // -> Error(Nil)\n/// ```\n///\npub fn square_root(x: Float) -> Result(Float, Nil) {\n  power(x, 0.5)\n}\n\n/// Returns the negative of the value provided.\n///\n/// ## Examples\n///\n/// ```gleam\n/// negate(1.0)\n/// // -> -1.0\n/// ```\n///\npub fn negate(x: Float) -> Float {\n  -1.0 *. x\n}\n\n/// Sums a list of `Float`s.\n///\n/// ## Example\n///\n/// ```gleam\n/// sum([1.0, 2.2, 3.3])\n/// // -> 6.5\n/// ```\n///\npub fn sum(numbers: List(Float)) -> Float {\n  sum_loop(numbers, 0.0)\n}\n\nfn sum_loop(numbers: List(Float), initial: Float) -> Float {\n  case numbers {\n    [first, ..rest] -> sum_loop(rest, first +. initial)\n    [] -> initial\n  }\n}\n\n/// Multiplies a list of `Float`s and returns the product.\n///\n/// ## Example\n///\n/// ```gleam\n/// product([2.5, 3.2, 4.2])\n/// // -> 33.6\n/// ```\n///\npub fn product(numbers: List(Float)) -> Float {\n  product_loop(numbers, 1.0)\n}\n\nfn product_loop(numbers: List(Float), initial: Float) -> Float {\n  case numbers {\n    [first, ..rest] -> product_loop(rest, first *. initial)\n    [] -> initial\n  }\n}\n\n/// Generates a random float between the given zero (inclusive) and one\n/// (exclusive).\n///\n/// On Erlang this updates the random state in the process dictionary.\n/// See: <https://www.erlang.org/doc/man/rand.html#uniform-0>\n///\n/// ## Examples\n///\n/// ```gleam\n/// random()\n/// // -> 0.646355926896028\n/// ```\n///\n@external(erlang, \"rand\", \"uniform\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"random_uniform\")\npub fn random() -> Float\n\n/// Computes the modulo of a float division of inputs as a `Result`.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// The computed value will always have the same sign as the `divisor`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// modulo(13.3, by: 3.3)\n/// // -> Ok(0.1)\n/// ```\n///\n/// ```gleam\n/// modulo(-13.3, by: 3.3)\n/// // -> Ok(3.2)\n/// ```\n///\n/// ```gleam\n/// modulo(13.3, by: -3.3)\n/// // -> Ok(-3.2)\n/// ```\n///\n/// ```gleam\n/// modulo(-13.3, by: -3.3)\n/// // -> Ok(-0.1)\n/// ```\n///\npub fn modulo(dividend: Float, by divisor: Float) -> Result(Float, Nil) {\n  case divisor {\n    0.0 -> Error(Nil)\n    _ -> Ok(dividend -. floor(dividend /. divisor) *. divisor)\n  }\n}\n\n/// Returns division of the inputs as a `Result`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// divide(0.0, 1.0)\n/// // -> Ok(0.0)\n/// ```\n///\n/// ```gleam\n/// divide(1.0, 0.0)\n/// // -> Error(Nil)\n/// ```\n///\npub fn divide(a: Float, by b: Float) -> Result(Float, Nil) {\n  case b {\n    0.0 -> Error(Nil)\n    b -> Ok(a /. b)\n  }\n}\n\n/// Adds two floats together.\n///\n/// It's the function equivalent of the `+.` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// add(1.0, 2.0)\n/// // -> 3.0\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n///\n/// list.fold([1.0, 2.0, 3.0], 0.0, add)\n/// // -> 6.0\n/// ```\n///\n/// ```gleam\n/// 3.0 |> add(2.0)\n/// // -> 5.0\n/// ```\n///\npub fn add(a: Float, b: Float) -> Float {\n  a +. b\n}\n\n/// Multiplies two floats together.\n///\n/// It's the function equivalent of the `*.` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// multiply(2.0, 4.0)\n/// // -> 8.0\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n///\n/// list.fold([2.0, 3.0, 4.0], 1.0, multiply)\n/// // -> 24.0\n/// ```\n///\n/// ```gleam\n/// 3.0 |> multiply(2.0)\n/// // -> 6.0\n/// ```\n///\npub fn multiply(a: Float, b: Float) -> Float {\n  a *. b\n}\n\n/// Subtracts one float from another.\n///\n/// It's the function equivalent of the `-.` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// subtract(3.0, 1.0)\n/// // -> 2.0\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n///\n/// list.fold([1.0, 2.0, 3.0], 10.0, subtract)\n/// // -> 4.0\n/// ```\n///\n/// ```gleam\n/// 3.0 |> subtract(_, 2.0)\n/// // -> 1.0\n/// ```\n///\n/// ```gleam\n/// 3.0 |> subtract(2.0, _)\n/// // -> -1.0\n/// ```\n///\npub fn subtract(a: Float, b: Float) -> Float {\n  a -. b\n}\n\n/// Returns the natural logarithm (base e) of the given `Float` as a `Result`. If the\n/// input is less than or equal to 0, returns `Error(Nil)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// logarithm(1.0)\n/// // -> Ok(0.0)\n/// ```\n///\n/// ```gleam\n/// logarithm(2.718281828459045)  // e\n/// // -> Ok(1.0)\n/// ```\n///\n/// ```gleam\n/// logarithm(0.0)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// logarithm(-1.0)\n/// // -> Error(Nil)\n/// ```\n///\npub fn logarithm(x: Float) -> Result(Float, Nil) {\n  // In the following check:\n  // 1. If x is negative then return an error as the natural logarithm\n  //    of a negative number is undefined (would be a complex number)\n  // 2. If x is 0 then return an error as the natural logarithm of 0\n  //    approaches negative infinity\n  case x <=. 0.0 {\n    True -> Error(Nil)\n    False -> Ok(do_log(x))\n  }\n}\n\n@external(erlang, \"math\", \"log\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"log\")\nfn do_log(x: Float) -> Float\n\n/// Returns e (Euler's number) raised to the power of the given exponent, as\n/// a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// exponential(0.0)\n/// // -> Ok(1.0)\n/// ```\n///\n/// ```gleam\n/// exponential(1.0)\n/// // -> Ok(2.718281828459045)\n/// ```\n///\n/// ```gleam\n/// exponential(-1.0)\n/// // -> Ok(0.36787944117144233)\n/// ```\n///\n@external(erlang, \"math\", \"exp\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"exp\")\npub fn exponential(x: Float) -> Float\n","gleam/function":"/// Takes a single argument and always returns its input value.\n///\npub fn identity(x: a) -> a {\n  x\n}\n","gleam/int":"//// Functions for working with integers.\n////\n//// ## Division by zero\n////\n//// In Erlang division by zero results in a crash, however Gleam does not have\n//// partial functions and operators in core so instead division by zero returns\n//// zero, a behaviour taken from Pony, Coq, and Lean.\n////\n//// This may seem unexpected at first, but it is no less mathematically valid\n//// than crashing or returning a special value. Division by zero is undefined\n//// in mathematics.\n\nimport gleam/float\nimport gleam/order.{type Order}\n\n/// Returns the absolute value of the input.\n///\n/// ## Examples\n///\n/// ```gleam\n/// absolute_value(-12)\n/// // -> 12\n/// ```\n///\n/// ```gleam\n/// absolute_value(10)\n/// // -> 10\n/// ```\n///\npub fn absolute_value(x: Int) -> Int {\n  case x >= 0 {\n    True -> x\n    False -> x * -1\n  }\n}\n\n/// Returns the result of the base being raised to the power of the\n/// exponent, as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// power(2, -1.0)\n/// // -> Ok(0.5)\n/// ```\n///\n/// ```gleam\n/// power(2, 2.0)\n/// // -> Ok(4.0)\n/// ```\n///\n/// ```gleam\n/// power(8, 1.5)\n/// // -> Ok(22.627416997969522)\n/// ```\n///\n/// ```gleam\n/// 4 |> power(of: 2.0)\n/// // -> Ok(16.0)\n/// ```\n///\n/// ```gleam\n/// power(-1, 0.5)\n/// // -> Error(Nil)\n/// ```\n///\npub fn power(base: Int, of exponent: Float) -> Result(Float, Nil) {\n  base\n  |> to_float\n  |> float.power(exponent)\n}\n\n/// Returns the square root of the input as a `Float`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// square_root(4)\n/// // -> Ok(2.0)\n/// ```\n///\n/// ```gleam\n/// square_root(-16)\n/// // -> Error(Nil)\n/// ```\n///\npub fn square_root(x: Int) -> Result(Float, Nil) {\n  x\n  |> to_float\n  |> float.square_root()\n}\n\n/// Parses a given string as an int if possible.\n///\n/// ## Examples\n///\n/// ```gleam\n/// parse(\"2\")\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// parse(\"ABC\")\n/// // -> Error(Nil)\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"parse_int\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"parse_int\")\npub fn parse(string: String) -> Result(Int, Nil)\n\n/// Parses a given string as an int in a given base if possible.\n/// Supports only bases 2 to 36, for values outside of which this function returns an `Error(Nil)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// base_parse(\"10\", 2)\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// base_parse(\"30\", 16)\n/// // -> Ok(48)\n/// ```\n///\n/// ```gleam\n/// base_parse(\"1C\", 36)\n/// // -> Ok(48)\n/// ```\n///\n/// ```gleam\n/// base_parse(\"48\", 1)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// base_parse(\"48\", 37)\n/// // -> Error(Nil)\n/// ```\n///\npub fn base_parse(string: String, base: Int) -> Result(Int, Nil) {\n  case base >= 2 && base <= 36 {\n    True -> do_base_parse(string, base)\n    False -> Error(Nil)\n  }\n}\n\n@external(erlang, \"gleam_stdlib\", \"int_from_base_string\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"int_from_base_string\")\nfn do_base_parse(a: String, b: Int) -> Result(Int, Nil)\n\n/// Prints a given int to a string.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_string(2)\n/// // -> \"2\"\n/// ```\n///\n@external(erlang, \"erlang\", \"integer_to_binary\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"to_string\")\npub fn to_string(x: Int) -> String\n\n/// Prints a given int to a string using the base number provided.\n/// Supports only bases 2 to 36, for values outside of which this function returns an `Error(Nil)`.\n/// For common bases (2, 8, 16, 36), use the `to_baseN` functions.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_base_string(2, 2)\n/// // -> Ok(\"10\")\n/// ```\n///\n/// ```gleam\n/// to_base_string(48, 16)\n/// // -> Ok(\"30\")\n/// ```\n///\n/// ```gleam\n/// to_base_string(48, 36)\n/// // -> Ok(\"1C\")\n/// ```\n///\n/// ```gleam\n/// to_base_string(48, 1)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// to_base_string(48, 37)\n/// // -> Error(Nil)\n/// ```\n///\npub fn to_base_string(x: Int, base: Int) -> Result(String, Nil) {\n  case base >= 2 && base <= 36 {\n    True -> Ok(do_to_base_string(x, base))\n    False -> Error(Nil)\n  }\n}\n\n@external(erlang, \"erlang\", \"integer_to_binary\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"int_to_base_string\")\nfn do_to_base_string(a: Int, b: Int) -> String\n\n/// Prints a given int to a string using base-2.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_base2(2)\n/// // -> \"10\"\n/// ```\n///\npub fn to_base2(x: Int) -> String {\n  do_to_base_string(x, 2)\n}\n\n/// Prints a given int to a string using base-8.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_base8(15)\n/// // -> \"17\"\n/// ```\n///\npub fn to_base8(x: Int) -> String {\n  do_to_base_string(x, 8)\n}\n\n/// Prints a given int to a string using base-16.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_base16(48)\n/// // -> \"30\"\n/// ```\n///\npub fn to_base16(x: Int) -> String {\n  do_to_base_string(x, 16)\n}\n\n/// Prints a given int to a string using base-36.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_base36(48)\n/// // -> \"1C\"\n/// ```\n///\npub fn to_base36(x: Int) -> String {\n  do_to_base_string(x, 36)\n}\n\n/// Takes an int and returns its value as a float.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_float(5)\n/// // -> 5.0\n/// ```\n///\n/// ```gleam\n/// to_float(0)\n/// // -> 0.0\n/// ```\n///\n/// ```gleam\n/// to_float(-3)\n/// // -> -3.0\n/// ```\n///\n@external(erlang, \"erlang\", \"float\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn to_float(x: Int) -> Float\n\n/// Restricts an int between two bounds.\n///\n/// Note: If the `min` argument is larger than the `max` argument then they\n/// will be swapped, so the minimum bound is always lower than the maximum\n/// bound.\n///\n/// ## Examples\n///\n/// ```gleam\n/// clamp(40, min: 50, max: 60)\n/// // -> 50\n/// ```\n///\n/// ```gleam\n/// clamp(40, min: 50, max: 30)\n/// // -> 40\n/// ```\n///\npub fn clamp(x: Int, min min_bound: Int, max max_bound: Int) -> Int {\n  case min_bound >= max_bound {\n    True -> x |> min(min_bound) |> max(max_bound)\n    False -> x |> min(max_bound) |> max(min_bound)\n  }\n}\n\n/// Compares two ints, returning an order.\n///\n/// ## Examples\n///\n/// ```gleam\n/// compare(2, 3)\n/// // -> Lt\n/// ```\n///\n/// ```gleam\n/// compare(4, 3)\n/// // -> Gt\n/// ```\n///\n/// ```gleam\n/// compare(3, 3)\n/// // -> Eq\n/// ```\n///\npub fn compare(a: Int, with b: Int) -> Order {\n  case a == b {\n    True -> order.Eq\n    False ->\n      case a < b {\n        True -> order.Lt\n        False -> order.Gt\n      }\n  }\n}\n\n/// Compares two ints, returning the smaller of the two.\n///\n/// ## Examples\n///\n/// ```gleam\n/// min(2, 3)\n/// // -> 2\n/// ```\n///\npub fn min(a: Int, b: Int) -> Int {\n  case a < b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Compares two ints, returning the larger of the two.\n///\n/// ## Examples\n///\n/// ```gleam\n/// max(2, 3)\n/// // -> 3\n/// ```\n///\npub fn max(a: Int, b: Int) -> Int {\n  case a > b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Returns whether the value provided is even.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_even(2)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// is_even(3)\n/// // -> False\n/// ```\n///\npub fn is_even(x: Int) -> Bool {\n  x % 2 == 0\n}\n\n/// Returns whether the value provided is odd.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_odd(3)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// is_odd(2)\n/// // -> False\n/// ```\n///\npub fn is_odd(x: Int) -> Bool {\n  x % 2 != 0\n}\n\n/// Returns the negative of the value provided.\n///\n/// ## Examples\n///\n/// ```gleam\n/// negate(1)\n/// // -> -1\n/// ```\n///\npub fn negate(x: Int) -> Int {\n  -1 * x\n}\n\n/// Sums a list of ints.\n///\n/// ## Example\n///\n/// ```gleam\n/// sum([1, 2, 3])\n/// // -> 6\n/// ```\n///\npub fn sum(numbers: List(Int)) -> Int {\n  sum_loop(numbers, 0)\n}\n\nfn sum_loop(numbers: List(Int), initial: Int) -> Int {\n  case numbers {\n    [first, ..rest] -> sum_loop(rest, first + initial)\n    [] -> initial\n  }\n}\n\n/// Multiplies a list of ints and returns the product.\n///\n/// ## Example\n///\n/// ```gleam\n/// product([2, 3, 4])\n/// // -> 24\n/// ```\n///\npub fn product(numbers: List(Int)) -> Int {\n  product_loop(numbers, 1)\n}\n\nfn product_loop(numbers: List(Int), initial: Int) -> Int {\n  case numbers {\n    [first, ..rest] -> product_loop(rest, first * initial)\n    [] -> initial\n  }\n}\n\n/// Generates a random int between zero and the given maximum.\n///\n/// The lower number is inclusive, the upper number is exclusive.\n///\n/// ## Examples\n///\n/// ```gleam\n/// random(10)\n/// // -> 4\n/// ```\n///\n/// ```gleam\n/// random(1)\n/// // -> 0\n/// ```\n///\n/// ```gleam\n/// random(-1)\n/// // -> -1\n/// ```\n///\npub fn random(max: Int) -> Int {\n  { float.random() *. to_float(max) }\n  |> float.floor\n  |> float.round\n}\n\n/// Performs a truncated integer division.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// divide(0, 1)\n/// // -> Ok(0)\n/// ```\n///\n/// ```gleam\n/// divide(1, 0)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// divide(5, 2)\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// divide(-99, 2)\n/// // -> Ok(-49)\n/// ```\n///\npub fn divide(dividend: Int, by divisor: Int) -> Result(Int, Nil) {\n  case divisor {\n    0 -> Error(Nil)\n    divisor -> Ok(dividend / divisor)\n  }\n}\n\n/// Computes the remainder of an integer division of inputs as a `Result`.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// Most of the time you will want to use the `%` operator instead of this\n/// function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// remainder(3, 2)\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// remainder(1, 0)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// remainder(10, -1)\n/// // -> Ok(0)\n/// ```\n///\n/// ```gleam\n/// remainder(13, by: 3)\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// remainder(-13, by: 3)\n/// // -> Ok(-1)\n/// ```\n///\n/// ```gleam\n/// remainder(13, by: -3)\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// remainder(-13, by: -3)\n/// // -> Ok(-1)\n/// ```\n///\npub fn remainder(dividend: Int, by divisor: Int) -> Result(Int, Nil) {\n  case divisor {\n    0 -> Error(Nil)\n    divisor -> Ok(dividend % divisor)\n  }\n}\n\n/// Computes the modulo of an integer division of inputs as a `Result`.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// Note that this is different from `int.remainder` and `%` in that the\n/// computed value will always have the same sign as the `divisor`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// modulo(3, 2)\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// modulo(1, 0)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// modulo(10, -1)\n/// // -> Ok(0)\n/// ```\n///\n/// ```gleam\n/// modulo(13, by: 3)\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// modulo(-13, by: 3)\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// modulo(13, by: -3)\n/// // -> Ok(-2)\n/// ```\n///\npub fn modulo(dividend: Int, by divisor: Int) -> Result(Int, Nil) {\n  case divisor {\n    0 -> Error(Nil)\n    _ -> {\n      let remainder = dividend % divisor\n      case remainder * divisor < 0 {\n        True -> Ok(remainder + divisor)\n        False -> Ok(remainder)\n      }\n    }\n  }\n}\n\n/// Performs a *floored* integer division, which means that the result will\n/// always be rounded towards negative infinity.\n///\n/// If you want to perform truncated integer division (rounding towards zero),\n/// use `int.divide()` or the `/` operator instead.\n///\n/// Returns division of the inputs as a `Result`: If the given divisor equals\n/// `0`, this function returns an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// floor_divide(1, 0)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// floor_divide(5, 2)\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// floor_divide(6, -4)\n/// // -> Ok(-2)\n/// ```\n///\n/// ```gleam\n/// floor_divide(-99, 2)\n/// // -> Ok(-50)\n/// ```\n///\npub fn floor_divide(dividend: Int, by divisor: Int) -> Result(Int, Nil) {\n  case divisor {\n    0 -> Error(Nil)\n    divisor ->\n      case dividend * divisor < 0 && dividend % divisor != 0 {\n        True -> Ok(dividend / divisor - 1)\n        False -> Ok(dividend / divisor)\n      }\n  }\n}\n\n/// Adds two integers together.\n///\n/// It's the function equivalent of the `+` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// add(1, 2)\n/// // -> 3\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n/// list.fold([1, 2, 3], 0, add)\n/// // -> 6\n/// ```\n///\n/// ```gleam\n/// 3 |> add(2)\n/// // -> 5\n/// ```\n///\npub fn add(a: Int, b: Int) -> Int {\n  a + b\n}\n\n/// Multiplies two integers together.\n///\n/// It's the function equivalent of the `*` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// multiply(2, 4)\n/// // -> 8\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n///\n/// list.fold([2, 3, 4], 1, multiply)\n/// // -> 24\n/// ```\n///\n/// ```gleam\n/// 3 |> multiply(2)\n/// // -> 6\n/// ```\n///\npub fn multiply(a: Int, b: Int) -> Int {\n  a * b\n}\n\n/// Subtracts one int from another.\n///\n/// It's the function equivalent of the `-` operator.\n/// This function is useful in higher order functions or pipes.\n///\n/// ## Examples\n///\n/// ```gleam\n/// subtract(3, 1)\n/// // -> 2\n/// ```\n///\n/// ```gleam\n/// import gleam/list\n///\n/// list.fold([1, 2, 3], 10, subtract)\n/// // -> 4\n/// ```\n///\n/// ```gleam\n/// 3 |> subtract(2)\n/// // -> 1\n/// ```\n///\n/// ```gleam\n/// 3 |> subtract(2, _)\n/// // -> -1\n/// ```\n///\npub fn subtract(a: Int, b: Int) -> Int {\n  a - b\n}\n\n/// Calculates the bitwise AND of its arguments.\n///\n/// The exact behaviour of this function depends on the target platform.\n/// On Erlang it is equivalent to bitwise operations on ints, on JavaScript it\n/// is equivalent to bitwise operations on big-ints.\n///\n@external(erlang, \"erlang\", \"band\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bitwise_and\")\npub fn bitwise_and(x: Int, y: Int) -> Int\n\n/// Calculates the bitwise NOT of its argument.\n///\n/// The exact behaviour of this function depends on the target platform.\n/// On Erlang it is equivalent to bitwise operations on ints, on JavaScript it\n/// is equivalent to bitwise operations on big-ints.\n///\n@external(erlang, \"erlang\", \"bnot\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bitwise_not\")\npub fn bitwise_not(x: Int) -> Int\n\n/// Calculates the bitwise OR of its arguments.\n///\n/// The exact behaviour of this function depends on the target platform.\n/// On Erlang it is equivalent to bitwise operations on ints, on JavaScript it\n/// is equivalent to bitwise operations on big-ints.\n///\n@external(erlang, \"erlang\", \"bor\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bitwise_or\")\npub fn bitwise_or(x: Int, y: Int) -> Int\n\n/// Calculates the bitwise XOR of its arguments.\n///\n/// The exact behaviour of this function depends on the target platform.\n/// On Erlang it is equivalent to bitwise operations on ints, on JavaScript it\n/// is equivalent to bitwise operations on big-ints.\n///\n@external(erlang, \"erlang\", \"bxor\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bitwise_exclusive_or\")\npub fn bitwise_exclusive_or(x: Int, y: Int) -> Int\n\n/// Calculates the result of an arithmetic left bitshift.\n///\n/// The exact behaviour of this function depends on the target platform.\n/// On Erlang it is equivalent to bitwise operations on ints, on JavaScript it\n/// is equivalent to bitwise operations on big-ints.\n///\n@external(erlang, \"erlang\", \"bsl\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bitwise_shift_left\")\npub fn bitwise_shift_left(x: Int, y: Int) -> Int\n\n/// Calculates the result of an arithmetic right bitshift.\n///\n/// The exact behaviour of this function depends on the target platform.\n/// On Erlang it is equivalent to bitwise operations on ints, on JavaScript it\n/// is equivalent to bitwise operations on big-ints.\n///\n@external(erlang, \"erlang\", \"bsr\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"bitwise_shift_right\")\npub fn bitwise_shift_right(x: Int, y: Int) -> Int\n\n/// Run a function for each int between ints `from` and `to`.\n///\n/// `from` is inclusive, and `to` is exclusive.\n///\n/// ## Examples\n///\n/// ```gleam\n/// range(from: 0, to: 3, with: \"\", run: fn(acc, i) {\n///   acc <> to_string(i)\n/// })\n/// // -> \"012\"\n/// ```\n///\n/// ```gleam\n/// range(from: 1, to: -2, with: [], run: list.prepend)\n/// // -> [-1, 0, 1]\n/// ```\n///\npub fn range(\n  from start: Int,\n  to stop: Int,\n  with acc: acc,\n  run reducer: fn(acc, Int) -> acc,\n) -> acc {\n  let increment = case start < stop {\n    True -> 1\n    False -> -1\n  }\n  range_loop(start, stop, increment, acc, reducer)\n}\n\nfn range_loop(\n  current: Int,\n  stop: Int,\n  increment: Int,\n  acc: acc,\n  reducer: fn(acc, Int) -> acc,\n) -> acc {\n  case current == stop {\n    True -> acc\n    False -> {\n      let acc = reducer(acc, current)\n      let current = current + increment\n      range_loop(current, stop, increment, acc, reducer)\n    }\n  }\n}\n","gleam/io":"/// Writes a string to standard output (stdout).\n///\n/// If you want your output to be printed on its own line see `println`.\n///\n/// ## Example\n///\n/// ```gleam\n/// io.print(\"Hi mum\")\n/// // -> Nil\n/// // Hi mum\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"print\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"print\")\npub fn print(string: String) -> Nil\n\n/// Writes a string to standard error (stderr).\n///\n/// If you want your output to be printed on its own line see `println_error`.\n///\n/// ## Example\n///\n/// ```gleam\n/// io.print_error(\"Hi pop\")\n/// // -> Nil\n/// // Hi pop\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"print_error\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"print_error\")\npub fn print_error(string: String) -> Nil\n\n/// Writes a string to standard output (stdout), appending a newline to the end.\n///\n/// ## Example\n///\n/// ```gleam\n/// io.println(\"Hi mum\")\n/// // -> Nil\n/// // Hi mum\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"println\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"console_log\")\npub fn println(string: String) -> Nil\n\n/// Writes a string to standard error (stderr), appending a newline to the end.\n///\n/// ## Example\n///\n/// ```gleam\n/// io.println_error(\"Hi pop\")\n/// // -> Nil\n/// // Hi pop\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"println_error\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"console_error\")\npub fn println_error(string: String) -> Nil\n","gleam/list":"//// Lists are an ordered sequence of elements and are one of the most common\n//// data types in Gleam.\n////\n//// New elements can be added and removed from the front of a list in\n//// constant time, while adding and removing from the end requires traversing\n//// and copying the whole list, so keep this in mind when designing your\n//// programs.\n////\n//// There is a dedicated syntax for prefixing to a list:\n////\n//// ```gleam\n//// let new_list = [1, 2, ..existing_list]\n//// ```\n////\n//// And a matching syntax for getting the first elements of a list:\n////\n//// ```gleam\n//// case list {\n////   [first_element, ..rest] -> first_element\n////   _ -> \"this pattern matches when the list is empty\"\n//// }\n//// ```\n////\n\nimport gleam/dict.{type Dict}\nimport gleam/float\nimport gleam/int\nimport gleam/order.{type Order}\n\n/// Counts the number of elements in a given list.\n///\n/// This function has to traverse the list to determine the number of elements,\n/// so it runs in linear time.\n///\n/// This function is natively implemented by the virtual machine and is highly\n/// optimised.\n///\n/// ## Examples\n///\n/// ```gleam\n/// length([])\n/// // -> 0\n/// ```\n///\n/// ```gleam\n/// length([1])\n/// // -> 1\n/// ```\n///\n/// ```gleam\n/// length([1, 2])\n/// // -> 2\n/// ```\n///\n@external(erlang, \"erlang\", \"length\")\npub fn length(of list: List(a)) -> Int {\n  length_loop(list, 0)\n}\n\nfn length_loop(list: List(a), count: Int) -> Int {\n  case list {\n    [_, ..list] -> length_loop(list, count + 1)\n    [] -> count\n  }\n}\n\n/// Counts the number of elements in a given list satisfying a given predicate.\n///\n/// This function has to traverse the list to determine the number of elements,\n/// so it runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// count([], fn(a) { a > 0 })\n/// // -> 0\n/// ```\n///\n/// ```gleam\n/// count([1], fn(a) { a > 0 })\n/// // -> 1\n/// ```\n///\n/// ```gleam\n/// count([1, 2, 3], int.is_odd)\n/// // -> 2\n/// ```\n///\npub fn count(list: List(a), where predicate: fn(a) -> Bool) -> Int {\n  count_loop(list, predicate, 0)\n}\n\nfn count_loop(list: List(a), predicate: fn(a) -> Bool, acc: Int) -> Int {\n  case list {\n    [] -> acc\n    [first, ..rest] ->\n      case predicate(first) {\n        True -> count_loop(rest, predicate, acc + 1)\n        False -> count_loop(rest, predicate, acc)\n      }\n  }\n}\n\n/// Creates a new list from a given list containing the same elements but in the\n/// opposite order.\n///\n/// This function has to traverse the list to create the new reversed list, so\n/// it runs in linear time.\n///\n/// This function is natively implemented by the virtual machine and is highly\n/// optimised.\n///\n/// ## Examples\n///\n/// ```gleam\n/// reverse([])\n/// // -> []\n/// ```\n///\n/// ```gleam\n/// reverse([1])\n/// // -> [1]\n/// ```\n///\n/// ```gleam\n/// reverse([1, 2])\n/// // -> [2, 1]\n/// ```\n///\n@external(erlang, \"lists\", \"reverse\")\npub fn reverse(list: List(a)) -> List(a) {\n  reverse_and_prepend(list, [])\n}\n\n/// Reverses a list and prepends it to another list.\n/// This function runs in linear time, proportional to the length of the list\n/// to prepend.\n///\n@external(erlang, \"lists\", \"reverse\")\nfn reverse_and_prepend(list prefix: List(a), to suffix: List(a)) -> List(a) {\n  case prefix {\n    [] -> suffix\n    [first, ..rest] -> reverse_and_prepend(list: rest, to: [first, ..suffix])\n  }\n}\n\n/// Determines whether or not the list is empty.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_empty([])\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// is_empty([1])\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// is_empty([1, 1])\n/// // -> False\n/// ```\n///\npub fn is_empty(list: List(a)) -> Bool {\n  list == []\n}\n\n/// Determines whether or not a given element exists within a given list.\n///\n/// This function traverses the list to find the element, so it runs in linear\n/// time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [] |> contains(any: 0)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// [0] |> contains(any: 0)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// [1] |> contains(any: 0)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// [1, 1] |> contains(any: 0)\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// [1, 0] |> contains(any: 0)\n/// // -> True\n/// ```\n///\npub fn contains(list: List(a), any elem: a) -> Bool {\n  case list {\n    [] -> False\n    [first, ..] if first == elem -> True\n    [_, ..rest] -> contains(rest, elem)\n  }\n}\n\n/// Gets the first element from the start of the list, if there is one.\n///\n/// ## Examples\n///\n/// ```gleam\n/// first([])\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// first([0])\n/// // -> Ok(0)\n/// ```\n///\n/// ```gleam\n/// first([1, 2])\n/// // -> Ok(1)\n/// ```\n///\npub fn first(list: List(a)) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [first, ..] -> Ok(first)\n  }\n}\n\n/// Returns the list minus the first element. If the list is empty, `Error(Nil)` is\n/// returned.\n///\n/// This function runs in constant time and does not make a copy of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// rest([])\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// rest([0])\n/// // -> Ok([])\n/// ```\n///\n/// ```gleam\n/// rest([1, 2])\n/// // -> Ok([2])\n/// ```\n///\npub fn rest(list: List(a)) -> Result(List(a), Nil) {\n  case list {\n    [] -> Error(Nil)\n    [_, ..rest] -> Ok(rest)\n  }\n}\n\n/// Groups the elements from the given list by the given key function.\n///\n/// Does not preserve the initial value order.\n///\n/// ## Examples\n///\n/// ```gleam\n/// import gleam/dict\n///\n/// [Ok(3), Error(\"Wrong\"), Ok(200), Ok(73)]\n/// |> group(by: fn(i) {\n///   case i {\n///     Ok(_) -> \"Successful\"\n///     Error(_) -> \"Failed\"\n///   }\n/// })\n/// |> dict.to_list\n/// // -> [\n/// //   #(\"Failed\", [Error(\"Wrong\")]),\n/// //   #(\"Successful\", [Ok(73), Ok(200), Ok(3)])\n/// // ]\n/// ```\n///\n/// ```gleam\n/// import gleam/dict\n///\n/// group([1,2,3,4,5], by: fn(i) { i - i / 3 * 3 })\n/// |> dict.to_list\n/// // -> [#(0, [3]), #(1, [4, 1]), #(2, [5, 2])]\n/// ```\n///\npub fn group(list: List(v), by key: fn(v) -> k) -> Dict(k, List(v)) {\n  dict.group(key, list)\n}\n\n/// Returns a new list containing only the elements from the first list for\n/// which the given functions returns `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// filter([2, 4, 6, 1], fn(x) { x > 2 })\n/// // -> [4, 6]\n/// ```\n///\n/// ```gleam\n/// filter([2, 4, 6, 1], fn(x) { x > 6 })\n/// // -> []\n/// ```\n///\npub fn filter(list: List(a), keeping predicate: fn(a) -> Bool) -> List(a) {\n  filter_loop(list, predicate, [])\n}\n\nfn filter_loop(list: List(a), fun: fn(a) -> Bool, acc: List(a)) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [first, ..rest] -> {\n      let new_acc = case fun(first) {\n        True -> [first, ..acc]\n        False -> acc\n      }\n      filter_loop(rest, fun, new_acc)\n    }\n  }\n}\n\n/// Returns a new list containing only the elements from the first list for\n/// which the given functions returns `Ok(_)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// filter_map([2, 4, 6, 1], Error)\n/// // -> []\n/// ```\n///\n/// ```gleam\n/// filter_map([2, 4, 6, 1], fn(x) { Ok(x + 1) })\n/// // -> [3, 5, 7, 2]\n/// ```\n///\npub fn filter_map(list: List(a), with fun: fn(a) -> Result(b, e)) -> List(b) {\n  filter_map_loop(list, fun, [])\n}\n\nfn filter_map_loop(\n  list: List(a),\n  fun: fn(a) -> Result(b, e),\n  acc: List(b),\n) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [first, ..rest] -> {\n      let new_acc = case fun(first) {\n        Ok(first) -> [first, ..acc]\n        Error(_) -> acc\n      }\n      filter_map_loop(rest, fun, new_acc)\n    }\n  }\n}\n\n/// Returns a new list containing the results of applying the supplied function to each element.\n///\n/// ## Examples\n///\n/// ```gleam\n/// map([2, 4, 6], fn(x) { x * 2 })\n/// // -> [4, 8, 12]\n/// ```\n///\npub fn map(list: List(a), with fun: fn(a) -> b) -> List(b) {\n  map_loop(list, fun, [])\n}\n\nfn map_loop(list: List(a), fun: fn(a) -> b, acc: List(b)) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [first, ..rest] -> map_loop(rest, fun, [fun(first), ..acc])\n  }\n}\n\n/// Combines two lists into a single list using the given function.\n///\n/// If a list is longer than the other, the extra elements are dropped.\n///\n/// ## Examples\n///\n/// ```gleam\n/// map2([1, 2, 3], [4, 5, 6], fn(x, y) { x + y })\n/// // -> [5, 7, 9]\n/// ```\n///\n/// ```gleam\n/// map2([1, 2], [\"a\", \"b\", \"c\"], fn(i, x) { #(i, x) })\n/// // -> [#(1, \"a\"), #(2, \"b\")]\n/// ```\n///\npub fn map2(list1: List(a), list2: List(b), with fun: fn(a, b) -> c) -> List(c) {\n  map2_loop(list1, list2, fun, [])\n}\n\nfn map2_loop(\n  list1: List(a),\n  list2: List(b),\n  fun: fn(a, b) -> c,\n  acc: List(c),\n) -> List(c) {\n  case list1, list2 {\n    [], _ | _, [] -> reverse(acc)\n    [a, ..as_], [b, ..bs] -> map2_loop(as_, bs, fun, [fun(a, b), ..acc])\n  }\n}\n\n/// Similar to `map` but also lets you pass around an accumulated value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// map_fold(\n///   over: [1, 2, 3],\n///   from: 100,\n///   with: fn(memo, i) { #(memo + i, i * 2) }\n/// )\n/// // -> #(106, [2, 4, 6])\n/// ```\n///\npub fn map_fold(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> #(acc, b),\n) -> #(acc, List(b)) {\n  map_fold_loop(list, fun, initial, [])\n}\n\nfn map_fold_loop(\n  list: List(a),\n  fun: fn(acc, a) -> #(acc, b),\n  acc: acc,\n  list_acc: List(b),\n) -> #(acc, List(b)) {\n  case list {\n    [] -> #(acc, reverse(list_acc))\n    [first, ..rest] -> {\n      let #(acc, first) = fun(acc, first)\n      map_fold_loop(rest, fun, acc, [first, ..list_acc])\n    }\n  }\n}\n\n/// Similar to `map`, but the supplied function will also be passed the index\n/// of the element being mapped as an additional argument.\n///\n/// The index starts at 0, so the first element is 0, the second is 1, and so\n/// on.\n///\n/// ## Examples\n///\n/// ```gleam\n/// index_map([\"a\", \"b\"], fn(x, i) { #(i, x) })\n/// // -> [#(0, \"a\"), #(1, \"b\")]\n/// ```\n///\npub fn index_map(list: List(a), with fun: fn(a, Int) -> b) -> List(b) {\n  index_map_loop(list, fun, 0, [])\n}\n\nfn index_map_loop(\n  list: List(a),\n  fun: fn(a, Int) -> b,\n  index: Int,\n  acc: List(b),\n) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [first, ..rest] -> {\n      let acc = [fun(first, index), ..acc]\n      index_map_loop(rest, fun, index + 1, acc)\n    }\n  }\n}\n\n/// Takes a function that returns a `Result` and applies it to each element in a\n/// given list in turn.\n///\n/// If the function returns `Ok(new_value)` for all elements in the list then a\n/// list of the new values is returned.\n///\n/// If the function returns `Error(reason)` for any of the elements then it is\n/// returned immediately. None of the elements in the list are processed after\n/// one returns an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// try_map([1, 2, 3], fn(x) { Ok(x + 2) })\n/// // -> Ok([3, 4, 5])\n/// ```\n///\n/// ```gleam\n/// try_map([1, 2, 3], fn(_) { Error(0) })\n/// // -> Error(0)\n/// ```\n///\n/// ```gleam\n/// try_map([[1], [2, 3]], first)\n/// // -> Ok([1, 2])\n/// ```\n///\n/// ```gleam\n/// try_map([[1], [], [2]], first)\n/// // -> Error(Nil)\n/// ```\n///\npub fn try_map(\n  over list: List(a),\n  with fun: fn(a) -> Result(b, e),\n) -> Result(List(b), e) {\n  try_map_loop(list, fun, [])\n}\n\nfn try_map_loop(\n  list: List(a),\n  fun: fn(a) -> Result(b, e),\n  acc: List(b),\n) -> Result(List(b), e) {\n  case list {\n    [] -> Ok(reverse(acc))\n    [first, ..rest] ->\n      case fun(first) {\n        Ok(first) -> try_map_loop(rest, fun, [first, ..acc])\n        Error(error) -> Error(error)\n      }\n  }\n}\n\n/// Returns a list that is the given list with up to the given number of\n/// elements removed from the front of the list.\n///\n/// If the list has less than the number of elements an empty list is\n/// returned.\n///\n/// This function runs in linear time but does not copy the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// drop([1, 2, 3, 4], 2)\n/// // -> [3, 4]\n/// ```\n///\n/// ```gleam\n/// drop([1, 2, 3, 4], 9)\n/// // -> []\n/// ```\n///\npub fn drop(from list: List(a), up_to n: Int) -> List(a) {\n  case n <= 0 {\n    True -> list\n    False ->\n      case list {\n        [] -> []\n        [_, ..rest] -> drop(rest, n - 1)\n      }\n  }\n}\n\n/// Returns a list containing the first given number of elements from the given\n/// list.\n///\n/// If the list has less than the number of elements then the full list is\n/// returned.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// take([1, 2, 3, 4], 2)\n/// // -> [1, 2]\n/// ```\n///\n/// ```gleam\n/// take([1, 2, 3, 4], 9)\n/// // -> [1, 2, 3, 4]\n/// ```\n///\npub fn take(from list: List(a), up_to n: Int) -> List(a) {\n  take_loop(list, n, [])\n}\n\nfn take_loop(list: List(a), n: Int, acc: List(a)) -> List(a) {\n  case n <= 0 {\n    True -> reverse(acc)\n    False ->\n      case list {\n        [] -> reverse(acc)\n        [first, ..rest] -> take_loop(rest, n - 1, [first, ..acc])\n      }\n  }\n}\n\n/// Returns a new empty list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new()\n/// // -> []\n/// ```\n///\npub fn new() -> List(a) {\n  []\n}\n\n/// Returns the given item wrapped in a list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// wrap(1)\n/// // -> [1]\n///\n/// wrap([\"a\", \"b\", \"c\"])\n/// // -> [[\"a\", \"b\", \"c\"]]\n///\n/// wrap([[]])\n/// // -> [[[]]]\n/// ```\n///\n///\npub fn wrap(item: a) -> List(a) {\n  [item]\n}\n\n/// Joins one list onto the end of another.\n///\n/// This function runs in linear time, and it traverses and copies the first\n/// list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// append([1, 2], [3])\n/// // -> [1, 2, 3]\n/// ```\n///\n@external(erlang, \"lists\", \"append\")\npub fn append(first: List(a), second: List(a)) -> List(a) {\n  append_loop(reverse(first), second)\n}\n\nfn append_loop(first: List(a), second: List(a)) -> List(a) {\n  case first {\n    [] -> second\n    [first, ..rest] -> append_loop(rest, [first, ..second])\n  }\n}\n\n/// Prefixes an item to a list. This can also be done using the dedicated\n/// syntax instead.\n///\n/// ```gleam\n/// let existing_list = [2, 3, 4]\n///\n/// [1, ..existing_list]\n/// // -> [1, 2, 3, 4]\n///\n/// prepend(to: existing_list, this: 1)\n/// // -> [1, 2, 3, 4]\n/// ```\n///\npub fn prepend(to list: List(a), this item: a) -> List(a) {\n  [item, ..list]\n}\n\n/// Joins a list of lists into a single list.\n///\n/// This function traverses all elements twice on the JavaScript target.\n/// This function traverses all elements once on the Erlang target.\n///\n/// ## Examples\n///\n/// ```gleam\n/// flatten([[1], [2, 3], []])\n/// // -> [1, 2, 3]\n/// ```\n///\n@external(erlang, \"lists\", \"append\")\npub fn flatten(lists: List(List(a))) -> List(a) {\n  flatten_loop(lists, [])\n}\n\nfn flatten_loop(lists: List(List(a)), acc: List(a)) -> List(a) {\n  case lists {\n    [] -> reverse(acc)\n    [list, ..further_lists] ->\n      flatten_loop(further_lists, reverse_and_prepend(list, to: acc))\n  }\n}\n\n/// Maps the list with the given function into a list of lists, and then flattens it.\n///\n/// ## Examples\n///\n/// ```gleam\n/// flat_map([2, 4, 6], fn(x) { [x, x + 1] })\n/// // -> [2, 3, 4, 5, 6, 7]\n/// ```\n///\npub fn flat_map(over list: List(a), with fun: fn(a) -> List(b)) -> List(b) {\n  flatten(map(list, fun))\n}\n\n/// Reduces a list of elements into a single value by calling a given function\n/// on each element, going from left to right.\n///\n/// `fold([1, 2, 3], 0, add)` is the equivalent of\n/// `add(add(add(0, 1), 2), 3)`.\n///\n/// This function runs in linear time.\n///\npub fn fold(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> acc {\n  case list {\n    [] -> initial\n    [first, ..rest] -> fold(rest, fun(initial, first), fun)\n  }\n}\n\n/// Reduces a list of elements into a single value by calling a given function\n/// on each element, going from right to left.\n///\n/// `fold_right([1, 2, 3], 0, add)` is the equivalent of\n/// `add(add(add(0, 3), 2), 1)`.\n///\n/// This function runs in linear time.\n///\n/// Unlike `fold` this function is not tail recursive. Where possible use\n/// `fold` instead as it will use less memory.\n///\npub fn fold_right(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> acc {\n  case list {\n    [] -> initial\n    [first, ..rest] -> fun(fold_right(rest, initial, fun), first)\n  }\n}\n\n/// Like `fold` but the folding function also receives the index of the current element.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [\"a\", \"b\", \"c\"]\n/// |> index_fold(\"\", fn(acc, item, index) {\n///    acc <> int.to_string(index) <> \":\" <> item <> \" \"\n/// })\n/// // -> \"0:a 1:b 2:c\"\n/// ```\n///\n/// ```gleam\n/// [10, 20, 30]\n/// |> index_fold(0, fn(acc, item, index) { acc + item * index })\n/// // -> 80\n/// ```\n///\npub fn index_fold(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a, Int) -> acc,\n) -> acc {\n  index_fold_loop(list, initial, fun, 0)\n}\n\nfn index_fold_loop(\n  over: List(a),\n  acc: acc,\n  with: fn(acc, a, Int) -> acc,\n  index: Int,\n) -> acc {\n  case over {\n    [] -> acc\n    [first, ..rest] ->\n      index_fold_loop(rest, with(acc, first, index), with, index + 1)\n  }\n}\n\n/// A variant of fold that might fail.\n///\n/// The folding function should return `Result(accumulator, error)`.\n/// If the returned value is `Ok(accumulator)` try_fold will try the next value in the list.\n/// If the returned value is `Error(error)` try_fold will stop and return that error.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [1, 2, 3, 4]\n/// |> try_fold(0, fn(acc, i) {\n///   case i < 3 {\n///     True -> Ok(acc + i)\n///     False -> Error(Nil)\n///   }\n/// })\n/// // -> Error(Nil)\n/// ```\n///\npub fn try_fold(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> Result(acc, e),\n) -> Result(acc, e) {\n  case list {\n    [] -> Ok(initial)\n    [first, ..rest] ->\n      case fun(initial, first) {\n        Ok(result) -> try_fold(rest, result, fun)\n        Error(_) as error -> error\n      }\n  }\n}\n\npub type ContinueOrStop(a) {\n  Continue(a)\n  Stop(a)\n}\n\n/// A variant of fold that allows to stop folding earlier.\n///\n/// The folding function should return `ContinueOrStop(accumulator)`.\n/// If the returned value is `Continue(accumulator)` fold_until will try the next value in the list.\n/// If the returned value is `Stop(accumulator)` fold_until will stop and return that accumulator.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [1, 2, 3, 4]\n/// |> fold_until(0, fn(acc, i) {\n///   case i < 3 {\n///     True -> Continue(acc + i)\n///     False -> Stop(acc)\n///   }\n/// })\n/// // -> 3\n/// ```\n///\npub fn fold_until(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> ContinueOrStop(acc),\n) -> acc {\n  case list {\n    [] -> initial\n    [first, ..rest] ->\n      case fun(initial, first) {\n        Continue(next_accumulator) -> fold_until(rest, next_accumulator, fun)\n        Stop(b) -> b\n      }\n  }\n}\n\n/// Finds the first element in a given list for which the given function returns\n/// `True`.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n/// ```gleam\n/// find([1, 2, 3], fn(x) { x > 2 })\n/// // -> Ok(3)\n/// ```\n///\n/// ```gleam\n/// find([1, 2, 3], fn(x) { x > 4 })\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// find([], fn(_) { True })\n/// // -> Error(Nil)\n/// ```\n///\npub fn find(\n  in list: List(a),\n  one_that is_desired: fn(a) -> Bool,\n) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [first, ..rest] ->\n      case is_desired(first) {\n        True -> Ok(first)\n        False -> find(in: rest, one_that: is_desired)\n      }\n  }\n}\n\n/// Finds the first element in a given list for which the given function returns\n/// `Ok(new_value)`, then returns the wrapped `new_value`.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n/// ```gleam\n/// find_map([[], [2], [3]], first)\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// find_map([[], []], first)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// find_map([], first)\n/// // -> Error(Nil)\n/// ```\n///\npub fn find_map(\n  in list: List(a),\n  with fun: fn(a) -> Result(b, c),\n) -> Result(b, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [first, ..rest] ->\n      case fun(first) {\n        Ok(first) -> Ok(first)\n        Error(_) -> find_map(in: rest, with: fun)\n      }\n  }\n}\n\n/// Returns `True` if the given function returns `True` for all the elements in\n/// the given list. If the function returns `False` for any of the elements it\n/// immediately returns `False` without checking the rest of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// all([], fn(x) { x > 3 })\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// all([4, 5], fn(x) { x > 3 })\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// all([4, 3], fn(x) { x > 3 })\n/// // -> False\n/// ```\n///\npub fn all(in list: List(a), satisfying predicate: fn(a) -> Bool) -> Bool {\n  case list {\n    [] -> True\n    [first, ..rest] ->\n      case predicate(first) {\n        True -> all(rest, predicate)\n        False -> False\n      }\n  }\n}\n\n/// Returns `True` if the given function returns `True` for any the elements in\n/// the given list. If the function returns `True` for any of the elements it\n/// immediately returns `True` without checking the rest of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// any([], fn(x) { x > 3 })\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// any([4, 5], fn(x) { x > 3 })\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// any([4, 3], fn(x) { x > 4 })\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// any([3, 4], fn(x) { x > 3 })\n/// // -> True\n/// ```\n///\npub fn any(in list: List(a), satisfying predicate: fn(a) -> Bool) -> Bool {\n  case list {\n    [] -> False\n    [first, ..rest] ->\n      case predicate(first) {\n        True -> True\n        False -> any(rest, predicate)\n      }\n  }\n}\n\n/// Takes two lists and returns a single list of 2-element tuples.\n///\n/// If one of the lists is longer than the other, the remaining elements from\n/// the longer list are not used.\n///\n/// ## Examples\n///\n/// ```gleam\n/// zip([], [])\n/// // -> []\n/// ```\n///\n/// ```gleam\n/// zip([1, 2], [3])\n/// // -> [#(1, 3)]\n/// ```\n///\n/// ```gleam\n/// zip([1], [3, 4])\n/// // -> [#(1, 3)]\n/// ```\n///\n/// ```gleam\n/// zip([1, 2], [3, 4])\n/// // -> [#(1, 3), #(2, 4)]\n/// ```\n///\npub fn zip(list: List(a), with other: List(b)) -> List(#(a, b)) {\n  zip_loop(list, other, [])\n}\n\nfn zip_loop(one: List(a), other: List(b), acc: List(#(a, b))) -> List(#(a, b)) {\n  case one, other {\n    [first_one, ..rest_one], [first_other, ..rest_other] ->\n      zip_loop(rest_one, rest_other, [#(first_one, first_other), ..acc])\n    _, _ -> reverse(acc)\n  }\n}\n\n/// Takes two lists and returns a single list of 2-element tuples.\n///\n/// If one of the lists is longer than the other, an `Error` is returned.\n///\n/// ## Examples\n///\n/// ```gleam\n/// strict_zip([], [])\n/// // -> Ok([])\n/// ```\n///\n/// ```gleam\n/// strict_zip([1, 2], [3])\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// strict_zip([1], [3, 4])\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// strict_zip([1, 2], [3, 4])\n/// // -> Ok([#(1, 3), #(2, 4)])\n/// ```\n///\npub fn strict_zip(\n  list: List(a),\n  with other: List(b),\n) -> Result(List(#(a, b)), Nil) {\n  strict_zip_loop(list, other, [])\n}\n\nfn strict_zip_loop(\n  one: List(a),\n  other: List(b),\n  acc: List(#(a, b)),\n) -> Result(List(#(a, b)), Nil) {\n  case one, other {\n    [], [] -> Ok(reverse(acc))\n    [], _ | _, [] -> Error(Nil)\n    [first_one, ..rest_one], [first_other, ..rest_other] ->\n      strict_zip_loop(rest_one, rest_other, [#(first_one, first_other), ..acc])\n  }\n}\n\n/// Takes a single list of 2-element tuples and returns two lists.\n///\n/// ## Examples\n///\n/// ```gleam\n/// unzip([#(1, 2), #(3, 4)])\n/// // -> #([1, 3], [2, 4])\n/// ```\n///\n/// ```gleam\n/// unzip([])\n/// // -> #([], [])\n/// ```\n///\npub fn unzip(input: List(#(a, b))) -> #(List(a), List(b)) {\n  unzip_loop(input, [], [])\n}\n\nfn unzip_loop(\n  input: List(#(a, b)),\n  one: List(a),\n  other: List(b),\n) -> #(List(a), List(b)) {\n  case input {\n    [] -> #(reverse(one), reverse(other))\n    [#(first_one, first_other), ..rest] ->\n      unzip_loop(rest, [first_one, ..one], [first_other, ..other])\n  }\n}\n\n/// Inserts a given value between each existing element in a given list.\n///\n/// This function runs in linear time and copies the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// intersperse([1, 1, 1], 2)\n/// // -> [1, 2, 1, 2, 1]\n/// ```\n///\n/// ```gleam\n/// intersperse([], 2)\n/// // -> []\n/// ```\n///\npub fn intersperse(list: List(a), with elem: a) -> List(a) {\n  case list {\n    [] | [_] -> list\n    [first, ..rest] -> intersperse_loop(rest, elem, [first])\n  }\n}\n\nfn intersperse_loop(list: List(a), separator: a, acc: List(a)) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [first, ..rest] ->\n      intersperse_loop(rest, separator, [first, separator, ..acc])\n  }\n}\n\n/// Removes any duplicate elements from a given list.\n///\n/// This function returns in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// unique([1, 1, 1, 4, 7, 3, 3, 4])\n/// // -> [1, 4, 7, 3]\n/// ```\n///\npub fn unique(list: List(a)) -> List(a) {\n  unique_loop(list, dict.new(), [])\n}\n\nfn unique_loop(list: List(a), seen: Dict(a, Nil), acc: List(a)) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [first, ..rest] ->\n      case dict.has_key(seen, first) {\n        True -> unique_loop(rest, seen, acc)\n        False ->\n          unique_loop(rest, dict.insert(seen, first, Nil), [first, ..acc])\n      }\n  }\n}\n\n/// Sorts from smallest to largest based upon the ordering specified by a given\n/// function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// import gleam/int\n///\n/// sort([4, 3, 6, 5, 4, 1, 2], by: int.compare)\n/// // -> [1, 2, 3, 4, 4, 5, 6]\n/// ```\n///\npub fn sort(list: List(a), by compare: fn(a, a) -> Order) -> List(a) {\n  // This is a natural, tail recursive, stable merge sort:\n  // - natural: it is very efficient if you call it on a list that is already\n  //   (pre)sorted because it works on slices of the original list.\n  // - tail recursive: the stack won't grow linearly with the size of the list.\n  // - stable: if two items are considered to be equal then their original\n  //   relative order is preserved.\n  case list {\n    // If the list has zero/one item then it's already sorted.\n    [] -> []\n    [x] -> [x]\n\n    // Otherwise the algorithm works as follow: we split the list in sequences\n    // of already sorted values as they appear in the list and then we merge\n    // those together two by two using `merge_all`.\n    [x, y, ..rest] -> {\n      // We need to compare the first two items to properly call `sequences`\n      // with the correct initial values. If the second item is <= than the\n      // first, then we know we'll start by growing a descending sequence\n      // (and an ascending one in the opposite case).\n      let direction = case compare(x, y) {\n        order.Lt | order.Eq -> Ascending\n        order.Gt -> Descending\n      }\n\n      // `sequences` produces sequences in ascending order so we call the\n      // `merge_all` function saying it to expect all sequences to be sorted\n      // that way.\n      let sequences = sequences(rest, compare, [x], direction, y, [])\n      merge_all(sequences, Ascending, compare)\n    }\n  }\n}\n\ntype Sorting {\n  Ascending\n  Descending\n}\n\n/// Given a list it returns slices of it that are locally sorted in ascending\n/// order.\n///\n/// Imagine you have this list:\n///\n/// ```\n///   [1, 2, 3, 2, 1, 0]\n///    ^^^^^^^  ^^^^^^^ This is a slice in descending order\n///    |\n///    | This is a slice that is sorted in ascending order\n/// ```\n///\n/// So the produced result will contain these two slices, each one sorted in\n/// ascending order: `[[1, 2, 3], [0, 1, 2]]`.\n///\n/// - `growing` is an accumulator with the current slice being grown\n/// - `direction` is the growing direction of the slice being grown, it could\n///   either be ascending or strictly descending\n/// - `prev` is the previous element that needs to be added to the growing slice\n///   it is carried around to check whether we have to keep growing the current\n///   slice or not\n/// - `acc` is the accumulator containing the slices sorted in ascending order\n///\nfn sequences(\n  list: List(a),\n  compare: fn(a, a) -> Order,\n  growing: List(a),\n  direction: Sorting,\n  prev: a,\n  acc: List(List(a)),\n) -> List(List(a)) {\n  // First of all we must not forget to add the previous element to the\n  // currently growing slice.\n  let growing = [prev, ..growing]\n\n  case list {\n    [] ->\n      case direction {\n        // Notice how we have to reverse the accumulator we're growing: since\n        // we always add items to the head, `growing` is built in the opposite\n        // sorting order of what it actually is in the original list.\n        Ascending -> [reverse(growing), ..acc]\n        Descending -> [growing, ..acc]\n      }\n\n    [new, ..rest] ->\n      case compare(prev, new), direction {\n        // In case the new element respects the ordering of the growing\n        // sequence, then we just keep growing it.\n        // Notice how a growing sequence is weakly growing (that is it can have\n        // consecutive equal items) while a decreasing sequence is strictly\n        // decreasing (no consecutive equal items), this is needed to make the\n        // algorithm stable!\n        order.Gt, Descending | order.Lt, Ascending | order.Eq, Ascending ->\n          sequences(rest, compare, growing, direction, new, acc)\n\n        // We were growing an ascending (descending) sequence and the new item\n        // is smaller (bigger) than the previous one, this means we have to stop\n        // growing this sequence and start with a new one whose first item will\n        // be the one we just found.\n        order.Gt, Ascending | order.Lt, Descending | order.Eq, Descending -> {\n          let acc = case direction {\n            Ascending -> [reverse(growing), ..acc]\n            Descending -> [growing, ..acc]\n          }\n          case rest {\n            // The list is over so we just create a sequence containing the last\n            // item we saw and add it to the accumulator before returning it.\n            [] -> [[new], ..acc]\n\n            // If the list is not over we have a peek at the next item to decide\n            // in which direction is growing the new sequence and make the\n            // recursive call with the appropriate arguments.\n            [next, ..rest] -> {\n              let direction = case compare(new, next) {\n                order.Lt | order.Eq -> Ascending\n                order.Gt -> Descending\n              }\n              sequences(rest, compare, [new], direction, next, acc)\n            }\n          }\n        }\n      }\n  }\n}\n\n/// Given some some sorted sequences (assumed to be sorted in `direction`) it\n/// merges them all together until we're left with just a list sorted in\n/// ascending order.\n///\nfn merge_all(\n  sequences: List(List(a)),\n  direction: Sorting,\n  compare: fn(a, a) -> Order,\n) -> List(a) {\n  case sequences, direction {\n    [], _ -> []\n\n    // If we have a single list in ascending order then we're done.\n    [sequence], Ascending -> sequence\n\n    // If we have a single list in descending order, we reverse it to make sure\n    // it's in ascending order and we're done.\n    [sequence], Descending -> reverse(sequence)\n\n    // Merging together sequences that are in ascending (descending) order\n    // reverses their order, so the recursive call will assume to be merging\n    // lists sorted in the opposite order!\n    _, Ascending -> {\n      let sequences = merge_ascending_pairs(sequences, compare, [])\n      merge_all(sequences, Descending, compare)\n    }\n\n    _, Descending -> {\n      let sequences = merge_descending_pairs(sequences, compare, [])\n      merge_all(sequences, Ascending, compare)\n    }\n  }\n}\n\n/// Given a list of ascending lists, it merges adjacent pairs into a single\n/// descending list, halving their number.\n/// It returns a list of the remaining descending lists.\n///\nfn merge_ascending_pairs(\n  sequences: List(List(a)),\n  compare: fn(a, a) -> Order,\n  acc: List(List(a)),\n) {\n  case sequences {\n    [] -> reverse(acc)\n\n    // Beware, if we have just one item left we must reverse it: we take\n    // ascending lists as input and have to return descending ones.\n    // If we returned it like it is it would be sorted in ascending order.\n    [sequence] -> reverse([reverse(sequence), ..acc])\n\n    [ascending1, ascending2, ..rest] -> {\n      let descending = merge_ascendings(ascending1, ascending2, compare, [])\n      merge_ascending_pairs(rest, compare, [descending, ..acc])\n    }\n  }\n}\n\n/// This is the same as merge_ascending_pairs but flipped for descending lists.\n///\nfn merge_descending_pairs(\n  sequences: List(List(a)),\n  compare: fn(a, a) -> Order,\n  acc: List(List(a)),\n) {\n  case sequences {\n    [] -> reverse(acc)\n\n    [sequence] -> reverse([reverse(sequence), ..acc])\n\n    [descending1, descending2, ..rest] -> {\n      let ascending = merge_descendings(descending1, descending2, compare, [])\n      merge_descending_pairs(rest, compare, [ascending, ..acc])\n    }\n  }\n}\n\n/// Merges two lists sorted in ascending order into a single list sorted in\n/// descending order according to the given comparator function.\n///\n/// This reversing of the sort order is not avoidable if we want to implement\n/// merge as a tail recursive function. We could reverse the accumulator before\n/// returning it but that would end up being less efficient; so the merging\n/// algorithm has to play around this.\n///\nfn merge_ascendings(\n  list1: List(a),\n  list2: List(a),\n  compare: fn(a, a) -> Order,\n  acc: List(a),\n) -> List(a) {\n  case list1, list2 {\n    [], list | list, [] -> reverse_and_prepend(list, acc)\n\n    [first1, ..rest1], [first2, ..rest2] ->\n      case compare(first1, first2) {\n        order.Lt -> merge_ascendings(rest1, list2, compare, [first1, ..acc])\n        order.Gt | order.Eq ->\n          merge_ascendings(list1, rest2, compare, [first2, ..acc])\n      }\n  }\n}\n\n/// This is exactly the same as merge_ascendings but mirrored: it merges two\n/// lists sorted in descending order into a single list sorted in ascending\n/// order according to the given comparator function.\n///\n/// This reversing of the sort order is not avoidable if we want to implement\n/// merge as a tail recursive function. We could reverse the accumulator before\n/// returning it but that would end up being less efficient; so the merging\n/// algorithm has to play around this.\n///\nfn merge_descendings(\n  list1: List(a),\n  list2: List(a),\n  compare: fn(a, a) -> Order,\n  acc: List(a),\n) -> List(a) {\n  case list1, list2 {\n    [], list | list, [] -> reverse_and_prepend(list, acc)\n    [first1, ..rest1], [first2, ..rest2] ->\n      case compare(first1, first2) {\n        order.Lt -> merge_descendings(list1, rest2, compare, [first2, ..acc])\n        order.Gt | order.Eq ->\n          merge_descendings(rest1, list2, compare, [first1, ..acc])\n      }\n  }\n}\n\n@deprecated(\"Use int.range instead\")\npub fn range(from start: Int, to stop: Int) -> List(Int) {\n  range_loop(start, stop, [])\n}\n\nfn range_loop(start: Int, stop: Int, acc: List(Int)) -> List(Int) {\n  case int.compare(start, stop) {\n    order.Eq -> [stop, ..acc]\n    order.Gt -> range_loop(start, stop + 1, [stop, ..acc])\n    order.Lt -> range_loop(start, stop - 1, [stop, ..acc])\n  }\n}\n\n/// Builds a list of a given value a given number of times.\n///\n/// ## Examples\n///\n/// ```gleam\n/// repeat(\"a\", times: 0)\n/// // -> []\n/// ```\n///\n/// ```gleam\n/// repeat(\"a\", times: 5)\n/// // -> [\"a\", \"a\", \"a\", \"a\", \"a\"]\n/// ```\n///\npub fn repeat(item a: a, times times: Int) -> List(a) {\n  repeat_loop(a, times, [])\n}\n\nfn repeat_loop(item: a, times: Int, acc: List(a)) -> List(a) {\n  case times <= 0 {\n    True -> acc\n    False -> repeat_loop(item, times - 1, [item, ..acc])\n  }\n}\n\n/// Splits a list in two before the given index.\n///\n/// If the list is not long enough to have the given index the before list will\n/// be the input list, and the after list will be empty.\n///\n/// ## Examples\n///\n/// ```gleam\n/// split([6, 7, 8, 9], 0)\n/// // -> #([], [6, 7, 8, 9])\n/// ```\n///\n/// ```gleam\n/// split([6, 7, 8, 9], 2)\n/// // -> #([6, 7], [8, 9])\n/// ```\n///\n/// ```gleam\n/// split([6, 7, 8, 9], 4)\n/// // -> #([6, 7, 8, 9], [])\n/// ```\n///\npub fn split(list list: List(a), at index: Int) -> #(List(a), List(a)) {\n  split_loop(list, index, [])\n}\n\nfn split_loop(list: List(a), n: Int, taken: List(a)) -> #(List(a), List(a)) {\n  case n <= 0 {\n    True -> #(reverse(taken), list)\n    False ->\n      case list {\n        [] -> #(reverse(taken), [])\n        [first, ..rest] -> split_loop(rest, n - 1, [first, ..taken])\n      }\n  }\n}\n\n/// Splits a list in two before the first element that a given function returns\n/// `False` for.\n///\n/// If the function returns `True` for all elements the first list will be the\n/// input list, and the second list will be empty.\n///\n/// ## Examples\n///\n/// ```gleam\n/// split_while([1, 2, 3, 4, 5], fn(x) { x <= 3 })\n/// // -> #([1, 2, 3], [4, 5])\n/// ```\n///\n/// ```gleam\n/// split_while([1, 2, 3, 4, 5], fn(x) { x <= 5 })\n/// // -> #([1, 2, 3, 4, 5], [])\n/// ```\n///\npub fn split_while(\n  list list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> #(List(a), List(a)) {\n  split_while_loop(list, predicate, [])\n}\n\nfn split_while_loop(\n  list: List(a),\n  f: fn(a) -> Bool,\n  acc: List(a),\n) -> #(List(a), List(a)) {\n  case list {\n    [] -> #(reverse(acc), [])\n    [first, ..rest] ->\n      case f(first) {\n        True -> split_while_loop(rest, f, [first, ..acc])\n        False -> #(reverse(acc), list)\n      }\n  }\n}\n\n/// Given a list of 2-element tuples, finds the first tuple that has a given\n/// key as the first element and returns the second element.\n///\n/// If no tuple is found with the given key then `Error(Nil)` is returned.\n///\n/// This function may be useful for interacting with Erlang code where lists of\n/// tuples are common.\n///\n/// ## Examples\n///\n/// ```gleam\n/// key_find([#(\"a\", 0), #(\"b\", 1)], \"a\")\n/// // -> Ok(0)\n/// ```\n///\n/// ```gleam\n/// key_find([#(\"a\", 0), #(\"b\", 1)], \"b\")\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// key_find([#(\"a\", 0), #(\"b\", 1)], \"c\")\n/// // -> Error(Nil)\n/// ```\n///\npub fn key_find(\n  in keyword_list: List(#(k, v)),\n  find desired_key: k,\n) -> Result(v, Nil) {\n  find_map(keyword_list, fn(keyword) {\n    let #(key, value) = keyword\n    case key == desired_key {\n      True -> Ok(value)\n      False -> Error(Nil)\n    }\n  })\n}\n\n/// Given a list of 2-element tuples, finds all tuples that have a given\n/// key as the first element and returns the second element.\n///\n/// This function may be useful for interacting with Erlang code where lists of\n/// tuples are common.\n///\n/// ## Examples\n///\n/// ```gleam\n/// key_filter([#(\"a\", 0), #(\"b\", 1), #(\"a\", 2)], \"a\")\n/// // -> [0, 2]\n/// ```\n///\n/// ```gleam\n/// key_filter([#(\"a\", 0), #(\"b\", 1)], \"c\")\n/// // -> []\n/// ```\n///\npub fn key_filter(\n  in keyword_list: List(#(k, v)),\n  find desired_key: k,\n) -> List(v) {\n  filter_map(keyword_list, fn(keyword) {\n    let #(key, value) = keyword\n    case key == desired_key {\n      True -> Ok(value)\n      False -> Error(Nil)\n    }\n  })\n}\n\n/// Given a list of 2-element tuples, finds the first tuple that has a given\n/// key as the first element. This function will return the second element\n/// of the found tuple and list with tuple removed.\n///\n/// If no tuple is found with the given key then `Error(Nil)` is returned.\n///\n/// ## Examples\n///\n/// ```gleam\n/// key_pop([#(\"a\", 0), #(\"b\", 1)], \"a\")\n/// // -> Ok(#(0, [#(\"b\", 1)]))\n/// ```\n///\n/// ```gleam\n/// key_pop([#(\"a\", 0), #(\"b\", 1)], \"b\")\n/// // -> Ok(#(1, [#(\"a\", 0)]))\n/// ```\n///\n/// ```gleam\n/// key_pop([#(\"a\", 0), #(\"b\", 1)], \"c\")\n/// // -> Error(Nil)\n/// ```\n///\npub fn key_pop(list: List(#(k, v)), key: k) -> Result(#(v, List(#(k, v))), Nil) {\n  key_pop_loop(list, key, [])\n}\n\nfn key_pop_loop(\n  list: List(#(k, v)),\n  key: k,\n  checked: List(#(k, v)),\n) -> Result(#(v, List(#(k, v))), Nil) {\n  case list {\n    [] -> Error(Nil)\n    [#(k, v), ..rest] if k == key ->\n      Ok(#(v, reverse_and_prepend(checked, rest)))\n    [first, ..rest] -> key_pop_loop(rest, key, [first, ..checked])\n  }\n}\n\n/// Given a list of 2-element tuples, inserts a key and value into the list.\n///\n/// If there was already a tuple with the key then it is replaced, otherwise it\n/// is added to the end of the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// key_set([#(5, 0), #(4, 1)], 4, 100)\n/// // -> [#(5, 0), #(4, 100)]\n/// ```\n///\n/// ```gleam\n/// key_set([#(5, 0), #(4, 1)], 1, 100)\n/// // -> [#(5, 0), #(4, 1), #(1, 100)]\n/// ```\n///\npub fn key_set(list: List(#(k, v)), key: k, value: v) -> List(#(k, v)) {\n  key_set_loop(list, key, value, [])\n}\n\nfn key_set_loop(\n  list: List(#(k, v)),\n  key: k,\n  value: v,\n  inspected: List(#(k, v)),\n) -> List(#(k, v)) {\n  case list {\n    [#(k, _), ..rest] if k == key ->\n      reverse_and_prepend(inspected, [#(k, value), ..rest])\n    [first, ..rest] -> key_set_loop(rest, key, value, [first, ..inspected])\n    [] -> reverse([#(key, value), ..inspected])\n  }\n}\n\n/// Calls a function for each element in a list, discarding the return value.\n///\n/// Useful for calling a side effect for every item of a list.\n///\n/// ```gleam\n/// import gleam/io\n///\n/// each([\"1\", \"2\", \"3\"], io.println)\n/// // -> Nil\n/// // 1\n/// // 2\n/// // 3\n/// ```\n///\npub fn each(list: List(a), f: fn(a) -> b) -> Nil {\n  case list {\n    [] -> Nil\n    [first, ..rest] -> {\n      f(first)\n      each(rest, f)\n    }\n  }\n}\n\n/// Calls a `Result` returning function for each element in a list, discarding\n/// the return value. If the function returns `Error` then the iteration is\n/// stopped and the error is returned.\n///\n/// Useful for calling a side effect for every item of a list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// try_each(\n///   over: [1, 2, 3],\n///   with: function_that_might_fail,\n/// )\n/// // -> Ok(Nil)\n/// ```\n///\npub fn try_each(\n  over list: List(a),\n  with fun: fn(a) -> Result(b, e),\n) -> Result(Nil, e) {\n  case list {\n    [] -> Ok(Nil)\n    [first, ..rest] ->\n      case fun(first) {\n        Ok(_) -> try_each(over: rest, with: fun)\n        Error(e) -> Error(e)\n      }\n  }\n}\n\n/// Partitions a list into a tuple/pair of lists\n/// by a given categorisation function.\n///\n/// ## Examples\n///\n/// ```gleam\n/// import gleam/int\n///\n/// [1, 2, 3, 4, 5] |> partition(int.is_odd)\n/// // -> #([1, 3, 5], [2, 4])\n/// ```\n///\npub fn partition(\n  list: List(a),\n  with categorise: fn(a) -> Bool,\n) -> #(List(a), List(a)) {\n  partition_loop(list, categorise, [], [])\n}\n\nfn partition_loop(list, categorise, trues, falses) {\n  case list {\n    [] -> #(reverse(trues), reverse(falses))\n    [first, ..rest] ->\n      case categorise(first) {\n        True -> partition_loop(rest, categorise, [first, ..trues], falses)\n        False -> partition_loop(rest, categorise, trues, [first, ..falses])\n      }\n  }\n}\n\n/// Returns all the permutations of a list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// permutations([1, 2])\n/// // -> [[1, 2], [2, 1]]\n/// ```\n///\npub fn permutations(list: List(a)) -> List(List(a)) {\n  case list {\n    [] -> [[]]\n    l -> permutation_zip(l, [], [])\n  }\n}\n\nfn permutation_zip(\n  list: List(a),\n  rest: List(a),\n  acc: List(List(a)),\n) -> List(List(a)) {\n  case list {\n    [] -> reverse(acc)\n    [head, ..tail] ->\n      permutation_prepend(\n        head,\n        permutations(reverse_and_prepend(rest, tail)),\n        tail,\n        [head, ..rest],\n        acc,\n      )\n  }\n}\n\nfn permutation_prepend(\n  el: a,\n  permutations: List(List(a)),\n  list_1: List(a),\n  list_2: List(a),\n  acc: List(List(a)),\n) -> List(List(a)) {\n  case permutations {\n    [] -> permutation_zip(list_1, list_2, acc)\n    [head, ..tail] ->\n      permutation_prepend(el, tail, list_1, list_2, [[el, ..head], ..acc])\n  }\n}\n\n/// Returns a list of sliding windows.\n///\n/// ## Examples\n///\n/// ```gleam\n/// window([1,2,3,4,5], 3)\n/// // -> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n/// ```\n///\n/// ```gleam\n/// window([1, 2], 4)\n/// // -> []\n/// ```\n///\npub fn window(list: List(a), by n: Int) -> List(List(a)) {\n  case n <= 0 {\n    True -> []\n    False -> window_loop([], list, n)\n  }\n}\n\nfn window_loop(acc: List(List(a)), list: List(a), n: Int) -> List(List(a)) {\n  let window = take(list, n)\n\n  case length(window) == n {\n    True -> window_loop([window, ..acc], drop(list, 1), n)\n    False -> reverse(acc)\n  }\n}\n\n/// Returns a list of tuples containing two contiguous elements.\n///\n/// ## Examples\n///\n/// ```gleam\n/// window_by_2([1,2,3,4])\n/// // -> [#(1, 2), #(2, 3), #(3, 4)]\n/// ```\n///\n/// ```gleam\n/// window_by_2([1])\n/// // -> []\n/// ```\n///\npub fn window_by_2(list: List(a)) -> List(#(a, a)) {\n  zip(list, drop(list, 1))\n}\n\n/// Drops the first elements in a given list for which the predicate function returns `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// drop_while([1, 2, 3, 4], fn (x) { x < 3 })\n/// // -> [3, 4]\n/// ```\n///\npub fn drop_while(\n  in list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> List(a) {\n  case list {\n    [] -> []\n    [first, ..rest] ->\n      case predicate(first) {\n        True -> drop_while(rest, predicate)\n        False -> [first, ..rest]\n      }\n  }\n}\n\n/// Takes the first elements in a given list for which the predicate function returns `True`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// take_while([1, 2, 3, 2, 4], fn (x) { x < 3 })\n/// // -> [1, 2]\n/// ```\n///\npub fn take_while(\n  in list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> List(a) {\n  take_while_loop(list, predicate, [])\n}\n\nfn take_while_loop(\n  list: List(a),\n  predicate: fn(a) -> Bool,\n  acc: List(a),\n) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [first, ..rest] ->\n      case predicate(first) {\n        True -> take_while_loop(rest, predicate, [first, ..acc])\n        False -> reverse(acc)\n      }\n  }\n}\n\n/// Returns a list of chunks in which\n/// the return value of calling `f` on each element is the same.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [1, 2, 2, 3, 4, 4, 6, 7, 7] |> chunk(by: fn(n) { n % 2 })\n/// // -> [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n/// ```\n///\npub fn chunk(in list: List(a), by f: fn(a) -> k) -> List(List(a)) {\n  case list {\n    [] -> []\n    [first, ..rest] -> chunk_loop(rest, f, f(first), [first], [])\n  }\n}\n\nfn chunk_loop(\n  list: List(a),\n  f: fn(a) -> k,\n  previous_key: k,\n  current_chunk: List(a),\n  acc: List(List(a)),\n) -> List(List(a)) {\n  case list {\n    [first, ..rest] -> {\n      let key = f(first)\n      case key == previous_key {\n        True -> chunk_loop(rest, f, key, [first, ..current_chunk], acc)\n        False -> {\n          let new_acc = [reverse(current_chunk), ..acc]\n          chunk_loop(rest, f, key, [first], new_acc)\n        }\n      }\n    }\n    [] -> reverse([reverse(current_chunk), ..acc])\n  }\n}\n\n/// Returns a list of chunks containing `count` elements each.\n///\n/// If the last chunk does not have `count` elements, it is instead\n/// a partial chunk, with less than `count` elements.\n///\n/// For any `count` less than 1 this function behaves as if it was set to 1.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [1, 2, 3, 4, 5, 6] |> sized_chunk(into: 2)\n/// // -> [[1, 2], [3, 4], [5, 6]]\n/// ```\n///\n/// ```gleam\n/// [1, 2, 3, 4, 5, 6, 7, 8] |> sized_chunk(into: 3)\n/// // -> [[1, 2, 3], [4, 5, 6], [7, 8]]\n/// ```\n///\npub fn sized_chunk(in list: List(a), into count: Int) -> List(List(a)) {\n  sized_chunk_loop(list, count, count, [], [])\n}\n\nfn sized_chunk_loop(\n  list: List(a),\n  count: Int,\n  left: Int,\n  current_chunk: List(a),\n  acc: List(List(a)),\n) -> List(List(a)) {\n  case list {\n    [] ->\n      case current_chunk {\n        [] -> reverse(acc)\n        remaining -> reverse([reverse(remaining), ..acc])\n      }\n    [first, ..rest] -> {\n      let chunk = [first, ..current_chunk]\n      case left > 1 {\n        True -> sized_chunk_loop(rest, count, left - 1, chunk, acc)\n        False ->\n          sized_chunk_loop(rest, count, count, [], [reverse(chunk), ..acc])\n      }\n    }\n  }\n}\n\n/// This function acts similar to fold, but does not take an initial state.\n/// Instead, it starts from the first element in the list\n/// and combines it with each subsequent element in turn using the given\n/// function. The function is called as `fun(accumulator, current_element)`.\n///\n/// Returns `Ok` to indicate a successful run, and `Error` if called on an\n/// empty list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// [] |> reduce(fn(acc, x) { acc + x })\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// [1, 2, 3, 4, 5] |> reduce(fn(acc, x) { acc + x })\n/// // -> Ok(15)\n/// ```\n///\npub fn reduce(over list: List(a), with fun: fn(a, a) -> a) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [first, ..rest] -> Ok(fold(rest, first, fun))\n  }\n}\n\n/// Similar to `fold`, but yields the state of the accumulator at each stage.\n///\n/// ## Examples\n///\n/// ```gleam\n/// scan(over: [1, 2, 3], from: 100, with: fn(acc, i) { acc + i })\n/// // -> [101, 103, 106]\n/// ```\n///\npub fn scan(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> List(acc) {\n  scan_loop(list, initial, [], fun)\n}\n\nfn scan_loop(\n  list: List(a),\n  accumulator: acc,\n  accumulated: List(acc),\n  fun: fn(acc, a) -> acc,\n) -> List(acc) {\n  case list {\n    [] -> reverse(accumulated)\n    [first, ..rest] -> {\n      let next = fun(accumulator, first)\n      scan_loop(rest, next, [next, ..accumulated], fun)\n    }\n  }\n}\n\n/// Returns the last element in the given list.\n///\n/// Returns `Error(Nil)` if the list is empty.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// last([])\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// last([1, 2, 3, 4, 5])\n/// // -> Ok(5)\n/// ```\n///\npub fn last(list: List(a)) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [last] -> Ok(last)\n    [_, ..rest] -> last(rest)\n  }\n}\n\n/// Return unique combinations of elements in the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// combinations([1, 2, 3], 2)\n/// // -> [[1, 2], [1, 3], [2, 3]]\n/// ```\n///\n/// ```gleam\n/// combinations([1, 2, 3, 4], 3)\n/// // -> [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]\n/// ```\n///\npub fn combinations(items: List(a), by n: Int) -> List(List(a)) {\n  case n, items {\n    0, _ -> [[]]\n    _, [] -> []\n    _, [first, ..rest] ->\n      rest\n      |> combinations(n - 1)\n      |> map(fn(combination) { [first, ..combination] })\n      |> reverse\n      |> fold(combinations(rest, n), fn(acc, c) { [c, ..acc] })\n  }\n}\n\n/// Return unique pair combinations of elements in the list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// combination_pairs([1, 2, 3])\n/// // -> [#(1, 2), #(1, 3), #(2, 3)]\n/// ```\n///\npub fn combination_pairs(items: List(a)) -> List(#(a, a)) {\n  combination_pairs_loop(items, [])\n}\n\nfn combination_pairs_loop(items: List(a), acc: List(#(a, a))) -> List(#(a, a)) {\n  case items {\n    [] -> reverse(acc)\n    [first, ..rest] -> {\n      let first_combinations = map(rest, with: fn(other) { #(first, other) })\n      let acc = reverse_and_prepend(first_combinations, acc)\n      combination_pairs_loop(rest, acc)\n    }\n  }\n}\n\n/// Make a list alternating the elements from the given lists\n///\n/// ## Examples\n///\n/// ```gleam\n/// interleave([[1, 2], [101, 102], [201, 202]])\n/// // -> [1, 101, 201, 2, 102, 202]\n/// ```\n///\npub fn interleave(list: List(List(a))) -> List(a) {\n  list\n  |> transpose\n  |> flatten\n}\n\n/// Transpose rows and columns of the list of lists.\n///\n/// Notice: This function is not tail recursive,\n/// and thus may exceed stack size if called,\n/// with large lists (on the JavaScript target).\n///\n/// ## Examples\n///\n/// ```gleam\n/// transpose([[1, 2, 3], [101, 102, 103]])\n/// // -> [[1, 101], [2, 102], [3, 103]]\n/// ```\n///\npub fn transpose(list_of_lists: List(List(a))) -> List(List(a)) {\n  transpose_loop(list_of_lists, [])\n}\n\nfn transpose_loop(rows: List(List(a)), columns: List(List(a))) -> List(List(a)) {\n  case rows {\n    [] -> reverse(columns)\n    _ -> {\n      let #(column, rest) = take_firsts(rows, [], [])\n      case column {\n        [_, ..] -> transpose_loop(rest, [column, ..columns])\n        [] -> transpose_loop(rest, columns)\n      }\n    }\n  }\n}\n\nfn take_firsts(\n  rows: List(List(a)),\n  column: List(a),\n  remaining_rows: List(List(a)),\n) -> #(List(a), List(List(a))) {\n  case rows {\n    [] -> #(reverse(column), reverse(remaining_rows))\n    [[], ..rest] -> take_firsts(rest, column, remaining_rows)\n    [[first, ..remaining_row], ..rest_rows] -> {\n      let remaining_rows = [remaining_row, ..remaining_rows]\n      take_firsts(rest_rows, [first, ..column], remaining_rows)\n    }\n  }\n}\n\n/// Takes a list, randomly sorts all items and returns the shuffled list.\n///\n/// This function uses `float.random` to decide the order of the elements.\n///\n/// ## Example\n///\n/// ```gleam\n/// range(1, 10) |> shuffle()\n/// // -> [1, 6, 9, 10, 3, 8, 4, 2, 7, 5]\n/// ```\n///\npub fn shuffle(list: List(a)) -> List(a) {\n  list\n  |> fold(from: [], with: fn(acc, a) { [#(float.random(), a), ..acc] })\n  |> do_shuffle_by_pair_indexes()\n  |> shuffle_pair_unwrap_loop([])\n}\n\nfn shuffle_pair_unwrap_loop(list: List(#(Float, a)), acc: List(a)) -> List(a) {\n  case list {\n    [] -> acc\n    [elem_pair, ..enumerable] ->\n      shuffle_pair_unwrap_loop(enumerable, [elem_pair.1, ..acc])\n  }\n}\n\nfn do_shuffle_by_pair_indexes(\n  list_of_pairs: List(#(Float, a)),\n) -> List(#(Float, a)) {\n  sort(list_of_pairs, fn(a_pair: #(Float, a), b_pair: #(Float, a)) -> Order {\n    float.compare(a_pair.0, b_pair.0)\n  })\n}\n\n/// Takes a list and a comparator, and returns the maximum element in the list\n///\n/// ## Examples\n///\n/// ```gleam\n/// range(1, 10) |> list.max(int.compare)\n/// // -> Ok(10)\n/// ```\n///\n/// ```gleam\n/// [\"a\", \"c\", \"b\"] |> list.max(string.compare)\n/// // -> Ok(\"c\")\n/// ```\n///\npub fn max(\n  over list: List(a),\n  with compare: fn(a, a) -> Order,\n) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [first, ..rest] -> Ok(max_loop(rest, compare, first))\n  }\n}\n\nfn max_loop(list, compare, max) {\n  case list {\n    [] -> max\n    [first, ..rest] ->\n      case compare(first, max) {\n        order.Gt -> max_loop(rest, compare, first)\n        order.Lt | order.Eq -> max_loop(rest, compare, max)\n      }\n  }\n}\n\n/// Returns a random sample of up to n elements from a list using reservoir\n/// sampling via [Algorithm L](https://en.wikipedia.org/wiki/Reservoir_sampling#Optimal:_Algorithm_L).\n/// Returns an empty list if the sample size is less than or equal to 0.\n///\n/// Order is not random, only selection is.\n///\n/// ## Examples\n///\n/// ```gleam\n/// reservoir_sample([1, 2, 3, 4, 5], 3)\n/// // -> [2, 4, 5]  // A random sample of 3 items\n/// ```\n///\npub fn sample(from list: List(a), up_to n: Int) -> List(a) {\n  let #(reservoir, rest) = build_reservoir(from: list, sized: n)\n\n  case dict.is_empty(reservoir) {\n    // If the reservoire is empty that means we were asking to sample 0 or\n    // less items. That doesn't make much sense, so we just return an empty\n    // list.\n    True -> []\n\n    // Otherwise we keep looping over the remaining part of the list replacing\n    // random elements in the reservoir.\n    False -> {\n      let w = float.exponential(log_random() /. int.to_float(n))\n      dict.values(sample_loop(rest, reservoir, n, w))\n    }\n  }\n}\n\nfn sample_loop(\n  list: List(a),\n  reservoir: Dict(Int, a),\n  n: Int,\n  w: Float,\n) -> Dict(Int, a) {\n  let skip = {\n    let assert Ok(log) = float.logarithm(1.0 -. w)\n    float.round(float.floor(log_random() /. log))\n  }\n\n  case drop(list, skip) {\n    [] -> reservoir\n    [first, ..rest] -> {\n      let reservoir = dict.insert(reservoir, int.random(n), first)\n      let w = w *. float.exponential(log_random() /. int.to_float(n))\n      sample_loop(rest, reservoir, n, w)\n    }\n  }\n}\n\nconst min_positive = 2.2250738585072014e-308\n\nfn log_random() -> Float {\n  let assert Ok(random) = float.logarithm(float.random() +. min_positive)\n  random\n}\n\n/// Builds the initial reservoir used by Algorithm L.\n/// This is a dictionary with keys ranging from `0` up to `n - 1` where each\n/// value is the corresponding element at that position in `list`.\n///\n/// This also returns the remaining elements of `list` that didn't end up in\n/// the reservoir.\n///\nfn build_reservoir(from list: List(a), sized n: Int) -> #(Dict(Int, a), List(a)) {\n  build_reservoir_loop(list, n, dict.new())\n}\n\nfn build_reservoir_loop(\n  list: List(a),\n  size: Int,\n  reservoir: Dict(Int, a),\n) -> #(Dict(Int, a), List(a)) {\n  let reservoir_size = dict.size(reservoir)\n  case reservoir_size >= size {\n    // The reservoir already has the size we wanted.\n    True -> #(reservoir, list)\n\n    // Otherwise we add another element from the list to the reservoir\n    False ->\n      case list {\n        [] -> #(reservoir, [])\n        [first, ..rest] -> {\n          let reservoir = dict.insert(reservoir, reservoir_size, first)\n          build_reservoir_loop(rest, size, reservoir)\n        }\n      }\n  }\n}\n","gleam/option":"/// `Option` represents a value that may be present or not. `Some` means the value is\n/// present, `None` means the value is not.\n///\n/// This is Gleam's alternative to having a value that could be Null, as is\n/// possible in some other languages.\n///\n/// ## `Option` and `Result`\n///\n/// In other languages fallible functions may return either `Result` or\n/// `Option` depending on whether there is more information to be given about the\n/// failure. In Gleam all fallible functions return `Result`, and `Nil` is used\n/// as the error if there is no extra detail to give. This consistency removes\n/// the boilerplate that would otherwise be needed to convert between `Option`\n/// and `Result` types, and makes APIs more predictable.\n///\n/// The `Option` type should only be used for taking optional values as\n/// function arguments, or for storing them in other data structures.\n///\npub type Option(a) {\n  Some(a)\n  None\n}\n\n/// Combines a list of `Option`s into a single `Option`.\n/// If all elements in the list are `Some` then returns a `Some` holding the list of values.\n/// If any element is `None` then returns `None`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// all([Some(1), Some(2)])\n/// // -> Some([1, 2])\n/// ```\n///\n/// ```gleam\n/// all([Some(1), None])\n/// // -> None\n/// ```\n///\npub fn all(list: List(Option(a))) -> Option(List(a)) {\n  all_loop(list, [])\n}\n\nfn all_loop(list: List(Option(a)), acc: List(a)) -> Option(List(a)) {\n  case list {\n    [] -> Some(reverse(acc))\n    [None, ..] -> None\n    [Some(first), ..rest] -> all_loop(rest, [first, ..acc])\n  }\n}\n\n// This is copied from the list module and not imported as importing it would\n// result in a circular dependency!\n@external(erlang, \"lists\", \"reverse\")\nfn reverse(list: List(a)) -> List(a) {\n  reverse_and_prepend(list, [])\n}\n\nfn reverse_and_prepend(list prefix: List(a), to suffix: List(a)) -> List(a) {\n  case prefix {\n    [] -> suffix\n    [first, ..rest] -> reverse_and_prepend(list: rest, to: [first, ..suffix])\n  }\n}\n\n/// Checks whether the `Option` is a `Some` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_some(Some(1))\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// is_some(None)\n/// // -> False\n/// ```\n///\npub fn is_some(option: Option(a)) -> Bool {\n  option != None\n}\n\n/// Checks whether the `Option` is a `None` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_none(Some(1))\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// is_none(None)\n/// // -> True\n/// ```\n///\npub fn is_none(option: Option(a)) -> Bool {\n  option == None\n}\n\n/// Converts an `Option` type to a `Result` type.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_result(Some(1), \"some_error\")\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// to_result(None, \"some_error\")\n/// // -> Error(\"some_error\")\n/// ```\n///\npub fn to_result(option: Option(a), e) -> Result(a, e) {\n  case option {\n    Some(a) -> Ok(a)\n    None -> Error(e)\n  }\n}\n\n/// Converts a `Result` type to an `Option` type.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_result(Ok(1))\n/// // -> Some(1)\n/// ```\n///\n/// ```gleam\n/// from_result(Error(\"some_error\"))\n/// // -> None\n/// ```\n///\npub fn from_result(result: Result(a, e)) -> Option(a) {\n  case result {\n    Ok(a) -> Some(a)\n    Error(_) -> None\n  }\n}\n\n/// Extracts the value from an `Option`, returning a default value if there is none.\n///\n/// ## Examples\n///\n/// ```gleam\n/// unwrap(Some(1), 0)\n/// // -> 1\n/// ```\n///\n/// ```gleam\n/// unwrap(None, 0)\n/// // -> 0\n/// ```\n///\npub fn unwrap(option: Option(a), or default: a) -> a {\n  case option {\n    Some(x) -> x\n    None -> default\n  }\n}\n\n/// Extracts the value from an `Option`, evaluating the default function if the option is `None`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// lazy_unwrap(Some(1), fn() { 0 })\n/// // -> 1\n/// ```\n///\n/// ```gleam\n/// lazy_unwrap(None, fn() { 0 })\n/// // -> 0\n/// ```\n///\npub fn lazy_unwrap(option: Option(a), or default: fn() -> a) -> a {\n  case option {\n    Some(x) -> x\n    None -> default()\n  }\n}\n\n/// Updates a value held within the `Some` of an `Option` by calling a given function\n/// on it.\n///\n/// If the `Option` is a `None` rather than `Some`, the function is not called and the\n/// `Option` stays the same.\n///\n/// ## Examples\n///\n/// ```gleam\n/// map(over: Some(1), with: fn(x) { x + 1 })\n/// // -> Some(2)\n/// ```\n///\n/// ```gleam\n/// map(over: None, with: fn(x) { x + 1 })\n/// // -> None\n/// ```\n///\npub fn map(over option: Option(a), with fun: fn(a) -> b) -> Option(b) {\n  case option {\n    Some(x) -> Some(fun(x))\n    None -> None\n  }\n}\n\n/// Merges a nested `Option` into a single layer.\n///\n/// ## Examples\n///\n/// ```gleam\n/// flatten(Some(Some(1)))\n/// // -> Some(1)\n/// ```\n///\n/// ```gleam\n/// flatten(Some(None))\n/// // -> None\n/// ```\n///\n/// ```gleam\n/// flatten(None)\n/// // -> None\n/// ```\n///\npub fn flatten(option: Option(Option(a))) -> Option(a) {\n  case option {\n    Some(x) -> x\n    None -> None\n  }\n}\n\n/// Updates a value held within the `Some` of an `Option` by calling a given function\n/// on it, where the given function also returns an `Option`. The two options are\n/// then merged together into one `Option`.\n///\n/// If the `Option` is a `None` rather than `Some` the function is not called and the\n/// option stays the same.\n///\n/// This function is the equivalent of calling `map` followed by `flatten`, and\n/// it is useful for chaining together multiple functions that return `Option`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// then(Some(1), fn(x) { Some(x + 1) })\n/// // -> Some(2)\n/// ```\n///\n/// ```gleam\n/// then(Some(1), fn(x) { Some(#(\"a\", x)) })\n/// // -> Some(#(\"a\", 1))\n/// ```\n///\n/// ```gleam\n/// then(Some(1), fn(_) { None })\n/// // -> None\n/// ```\n///\n/// ```gleam\n/// then(None, fn(x) { Some(x + 1) })\n/// // -> None\n/// ```\n///\npub fn then(option: Option(a), apply fun: fn(a) -> Option(b)) -> Option(b) {\n  case option {\n    Some(x) -> fun(x)\n    None -> None\n  }\n}\n\n/// Returns the first value if it is `Some`, otherwise returns the second value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// or(Some(1), Some(2))\n/// // -> Some(1)\n/// ```\n///\n/// ```gleam\n/// or(Some(1), None)\n/// // -> Some(1)\n/// ```\n///\n/// ```gleam\n/// or(None, Some(2))\n/// // -> Some(2)\n/// ```\n///\n/// ```gleam\n/// or(None, None)\n/// // -> None\n/// ```\n///\npub fn or(first: Option(a), second: Option(a)) -> Option(a) {\n  case first {\n    Some(_) -> first\n    None -> second\n  }\n}\n\n/// Returns the first value if it is `Some`, otherwise evaluates the given function for a fallback value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// lazy_or(Some(1), fn() { Some(2) })\n/// // -> Some(1)\n/// ```\n///\n/// ```gleam\n/// lazy_or(Some(1), fn() { None })\n/// // -> Some(1)\n/// ```\n///\n/// ```gleam\n/// lazy_or(None, fn() { Some(2) })\n/// // -> Some(2)\n/// ```\n///\n/// ```gleam\n/// lazy_or(None, fn() { None })\n/// // -> None\n/// ```\n///\npub fn lazy_or(first: Option(a), second: fn() -> Option(a)) -> Option(a) {\n  case first {\n    Some(_) -> first\n    None -> second()\n  }\n}\n\n/// Given a list of `Option`s,\n/// returns only the values inside `Some`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// values([Some(1), None, Some(3)])\n/// // -> [1, 3]\n/// ```\n///\npub fn values(options: List(Option(a))) -> List(a) {\n  values_loop(options, [])\n}\n\nfn values_loop(list: List(Option(a)), acc: List(a)) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [None, ..rest] -> values_loop(rest, acc)\n    [Some(first), ..rest] -> values_loop(rest, [first, ..acc])\n  }\n}\n","gleam/order":"/// Represents the result of a single comparison to determine the precise\n/// ordering of two values.\n///\npub type Order {\n  /// Less-than\n  Lt\n\n  /// Equal\n  Eq\n\n  /// Greater than\n  Gt\n}\n\n/// Inverts an order, so less-than becomes greater-than and greater-than\n/// becomes less-than.\n///\n/// ## Examples\n///\n/// ```gleam\n/// negate(Lt)\n/// // -> Gt\n/// ```\n///\n/// ```gleam\n/// negate(Eq)\n/// // -> Eq\n/// ```\n///\n/// ```gleam\n/// negate(Gt)\n/// // -> Lt\n/// ```\n///\npub fn negate(order: Order) -> Order {\n  case order {\n    Lt -> Gt\n    Eq -> Eq\n    Gt -> Lt\n  }\n}\n\n/// Produces a numeric representation of the order.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_int(Lt)\n/// // -> -1\n/// ```\n///\n/// ```gleam\n/// to_int(Eq)\n/// // -> 0\n/// ```\n///\n/// ```gleam\n/// to_int(Gt)\n/// // -> 1\n/// ```\n///\npub fn to_int(order: Order) -> Int {\n  case order {\n    Lt -> -1\n    Eq -> 0\n    Gt -> 1\n  }\n}\n\n/// Compares two `Order` values to one another, producing a new `Order`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// compare(Eq, with: Lt)\n/// // -> Gt\n/// ```\n///\npub fn compare(a: Order, with b: Order) -> Order {\n  case a, b {\n    x, y if x == y -> Eq\n    Lt, _ | Eq, Gt -> Lt\n    _, _ -> Gt\n  }\n}\n\n/// Inverts an ordering function, so less-than becomes greater-than and greater-than\n/// becomes less-than.\n///\n/// ## Examples\n///\n/// ```gleam\n/// import gleam/int\n/// import gleam/list\n///\n/// list.sort([1, 5, 4], by: reverse(int.compare))\n/// // -> [5, 4, 1]\n/// ```\n///\npub fn reverse(orderer: fn(a, a) -> Order) -> fn(a, a) -> Order {\n  fn(a, b) { orderer(b, a) }\n}\n\n/// Return a fallback `Order` in case the first argument is `Eq`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// import gleam/int\n///\n/// break_tie(in: int.compare(1, 1), with: Lt)\n/// // -> Lt\n/// ```\n///\n/// ```gleam\n/// import gleam/int\n///\n/// break_tie(in: int.compare(1, 0), with: Eq)\n/// // -> Gt\n/// ```\n///\npub fn break_tie(in order: Order, with other: Order) -> Order {\n  case order {\n    Lt | Gt -> order\n    Eq -> other\n  }\n}\n\n/// Invokes a fallback function returning an `Order` in case the first argument\n/// is `Eq`.\n///\n/// This can be useful when the fallback comparison might be expensive and it\n/// needs to be delayed until strictly necessary.\n///\n/// ## Examples\n///\n/// ```gleam\n/// import gleam/int\n///\n/// lazy_break_tie(in: int.compare(1, 1), with: fn() { Lt })\n/// // -> Lt\n/// ```\n///\n/// ```gleam\n/// import gleam/int\n///\n/// lazy_break_tie(in: int.compare(1, 0), with: fn() { Eq })\n/// // -> Gt\n/// ```\n///\npub fn lazy_break_tie(in order: Order, with comparison: fn() -> Order) -> Order {\n  case order {\n    Lt | Gt -> order\n    Eq -> comparison()\n  }\n}\n","gleam/pair":"/// Returns the first element in a pair.\n///\n/// ## Examples\n///\n/// ```gleam\n/// first(#(1, 2))\n/// // -> 1\n/// ```\n///\npub fn first(pair: #(a, b)) -> a {\n  let #(a, _) = pair\n  a\n}\n\n/// Returns the second element in a pair.\n///\n/// ## Examples\n///\n/// ```gleam\n/// second(#(1, 2))\n/// // -> 2\n/// ```\n///\npub fn second(pair: #(a, b)) -> b {\n  let #(_, a) = pair\n  a\n}\n\n/// Returns a new pair with the elements swapped.\n///\n/// ## Examples\n///\n/// ```gleam\n/// swap(#(1, 2))\n/// // -> #(2, 1)\n/// ```\n///\npub fn swap(pair: #(a, b)) -> #(b, a) {\n  let #(a, b) = pair\n  #(b, a)\n}\n\n/// Returns a new pair with the first element having had `with` applied to\n/// it.\n///\n/// ## Examples\n///\n/// ```gleam\n/// #(1, 2) |> map_first(fn(n) { n * 2 })\n/// // -> #(2, 2)\n/// ```\n///\npub fn map_first(of pair: #(a, b), with fun: fn(a) -> c) -> #(c, b) {\n  let #(a, b) = pair\n  #(fun(a), b)\n}\n\n/// Returns a new pair with the second element having had `with` applied to\n/// it.\n///\n/// ## Examples\n///\n/// ```gleam\n/// #(1, 2) |> map_second(fn(n) { n * 2 })\n/// // -> #(1, 4)\n/// ```\n///\npub fn map_second(of pair: #(a, b), with fun: fn(b) -> c) -> #(a, c) {\n  let #(a, b) = pair\n  #(a, fun(b))\n}\n\n/// Returns a new pair with the given elements. This can also be done using the dedicated\n/// syntax instead: `new(1, 2) == #(1, 2)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new(1, 2)\n/// // -> #(1, 2)\n/// ```\n///\npub fn new(first: a, second: b) -> #(a, b) {\n  #(first, second)\n}\n","gleam/result":"//// Result represents the result of something that may succeed or not.\n//// `Ok` means it was successful, `Error` means it was not successful.\n\nimport gleam/list\n\n/// Checks whether the result is an `Ok` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_ok(Ok(1))\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// is_ok(Error(Nil))\n/// // -> False\n/// ```\n///\npub fn is_ok(result: Result(a, e)) -> Bool {\n  case result {\n    Error(_) -> False\n    Ok(_) -> True\n  }\n}\n\n/// Checks whether the result is an `Error` value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_error(Ok(1))\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// is_error(Error(Nil))\n/// // -> True\n/// ```\n///\npub fn is_error(result: Result(a, e)) -> Bool {\n  case result {\n    Ok(_) -> False\n    Error(_) -> True\n  }\n}\n\n/// Updates a value held within the `Ok` of a result by calling a given function\n/// on it.\n///\n/// If the result is an `Error` rather than `Ok` the function is not called and the\n/// result stays the same.\n///\n/// ## Examples\n///\n/// ```gleam\n/// map(over: Ok(1), with: fn(x) { x + 1 })\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// map(over: Error(1), with: fn(x) { x + 1 })\n/// // -> Error(1)\n/// ```\n///\npub fn map(over result: Result(a, e), with fun: fn(a) -> b) -> Result(b, e) {\n  case result {\n    Ok(x) -> Ok(fun(x))\n    Error(e) -> Error(e)\n  }\n}\n\n/// Updates a value held within the `Error` of a result by calling a given function\n/// on it.\n///\n/// If the result is `Ok` rather than `Error` the function is not called and the\n/// result stays the same.\n///\n/// ## Examples\n///\n/// ```gleam\n/// map_error(over: Error(1), with: fn(x) { x + 1 })\n/// // -> Error(2)\n/// ```\n///\n/// ```gleam\n/// map_error(over: Ok(1), with: fn(x) { x + 1 })\n/// // -> Ok(1)\n/// ```\n///\npub fn map_error(\n  over result: Result(a, e),\n  with fun: fn(e) -> f,\n) -> Result(a, f) {\n  case result {\n    Ok(x) -> Ok(x)\n    Error(error) -> Error(fun(error))\n  }\n}\n\n/// Merges a nested `Result` into a single layer.\n///\n/// ## Examples\n///\n/// ```gleam\n/// flatten(Ok(Ok(1)))\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// flatten(Ok(Error(\"\")))\n/// // -> Error(\"\")\n/// ```\n///\n/// ```gleam\n/// flatten(Error(Nil))\n/// // -> Error(Nil)\n/// ```\n///\npub fn flatten(result: Result(Result(a, e), e)) -> Result(a, e) {\n  case result {\n    Ok(x) -> x\n    Error(error) -> Error(error)\n  }\n}\n\n/// \"Updates\" an `Ok` result by passing its value to a function that yields a result,\n/// and returning the yielded result. (This may \"replace\" the `Ok` with an `Error`.)\n///\n/// If the input is an `Error` rather than an `Ok`, the function is not called and\n/// the original `Error` is returned.\n///\n/// This function is the equivalent of calling `map` followed by `flatten`, and\n/// it is useful for chaining together multiple functions that may fail.\n///\n/// ## Examples\n///\n/// ```gleam\n/// try(Ok(1), fn(x) { Ok(x + 1) })\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// try(Ok(1), fn(x) { Ok(#(\"a\", x)) })\n/// // -> Ok(#(\"a\", 1))\n/// ```\n///\n/// ```gleam\n/// try(Ok(1), fn(_) { Error(\"Oh no\") })\n/// // -> Error(\"Oh no\")\n/// ```\n///\n/// ```gleam\n/// try(Error(Nil), fn(x) { Ok(x + 1) })\n/// // -> Error(Nil)\n/// ```\n///\npub fn try(\n  result: Result(a, e),\n  apply fun: fn(a) -> Result(b, e),\n) -> Result(b, e) {\n  case result {\n    Ok(x) -> fun(x)\n    Error(e) -> Error(e)\n  }\n}\n\n/// Extracts the `Ok` value from a result, returning a default value if the result\n/// is an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// unwrap(Ok(1), 0)\n/// // -> 1\n/// ```\n///\n/// ```gleam\n/// unwrap(Error(\"\"), 0)\n/// // -> 0\n/// ```\n///\npub fn unwrap(result: Result(a, e), or default: a) -> a {\n  case result {\n    Ok(v) -> v\n    Error(_) -> default\n  }\n}\n\n/// Extracts the `Ok` value from a result, evaluating the default function if the result\n/// is an `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// lazy_unwrap(Ok(1), fn() { 0 })\n/// // -> 1\n/// ```\n///\n/// ```gleam\n/// lazy_unwrap(Error(\"\"), fn() { 0 })\n/// // -> 0\n/// ```\n///\npub fn lazy_unwrap(result: Result(a, e), or default: fn() -> a) -> a {\n  case result {\n    Ok(v) -> v\n    Error(_) -> default()\n  }\n}\n\n/// Extracts the `Error` value from a result, returning a default value if the result\n/// is an `Ok`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// unwrap_error(Error(1), 0)\n/// // -> 1\n/// ```\n///\n/// ```gleam\n/// unwrap_error(Ok(\"\"), 0)\n/// // -> 0\n/// ```\n///\npub fn unwrap_error(result: Result(a, e), or default: e) -> e {\n  case result {\n    Ok(_) -> default\n    Error(e) -> e\n  }\n}\n\n/// Returns the first value if it is `Ok`, otherwise returns the second value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// or(Ok(1), Ok(2))\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// or(Ok(1), Error(\"Error 2\"))\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// or(Error(\"Error 1\"), Ok(2))\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// or(Error(\"Error 1\"), Error(\"Error 2\"))\n/// // -> Error(\"Error 2\")\n/// ```\n///\npub fn or(first: Result(a, e), second: Result(a, e)) -> Result(a, e) {\n  case first {\n    Ok(_) -> first\n    Error(_) -> second\n  }\n}\n\n/// Returns the first value if it is `Ok`, otherwise evaluates the given function for a fallback value.\n///\n/// If you need access to the initial error value, use `result.try_recover`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// lazy_or(Ok(1), fn() { Ok(2) })\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// lazy_or(Ok(1), fn() { Error(\"Error 2\") })\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// lazy_or(Error(\"Error 1\"), fn() { Ok(2) })\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// lazy_or(Error(\"Error 1\"), fn() { Error(\"Error 2\") })\n/// // -> Error(\"Error 2\")\n/// ```\n///\npub fn lazy_or(\n  first: Result(a, e),\n  second: fn() -> Result(a, e),\n) -> Result(a, e) {\n  case first {\n    Ok(_) -> first\n    Error(_) -> second()\n  }\n}\n\n/// Combines a list of results into a single result.\n/// If all elements in the list are `Ok` then returns an `Ok` holding the list of values.\n/// If any element is `Error` then returns the first error.\n///\n/// ## Examples\n///\n/// ```gleam\n/// all([Ok(1), Ok(2)])\n/// // -> Ok([1, 2])\n/// ```\n///\n/// ```gleam\n/// all([Ok(1), Error(\"e\")])\n/// // -> Error(\"e\")\n/// ```\n///\npub fn all(results: List(Result(a, e))) -> Result(List(a), e) {\n  list.try_map(results, fn(result) { result })\n}\n\n/// Given a list of results, returns a pair where the first element is a list\n/// of all the values inside `Ok` and the second element is a list with all the\n/// values inside `Error`. The values in both lists appear in reverse order with\n/// respect to their position in the original list of results.\n///\n/// ## Examples\n///\n/// ```gleam\n/// partition([Ok(1), Error(\"a\"), Error(\"b\"), Ok(2)])\n/// // -> #([2, 1], [\"b\", \"a\"])\n/// ```\n///\npub fn partition(results: List(Result(a, e))) -> #(List(a), List(e)) {\n  partition_loop(results, [], [])\n}\n\nfn partition_loop(results: List(Result(a, e)), oks: List(a), errors: List(e)) {\n  case results {\n    [] -> #(oks, errors)\n    [Ok(a), ..rest] -> partition_loop(rest, [a, ..oks], errors)\n    [Error(e), ..rest] -> partition_loop(rest, oks, [e, ..errors])\n  }\n}\n\n/// Replace the value within a result\n///\n/// ## Examples\n///\n/// ```gleam\n/// replace(Ok(1), Nil)\n/// // -> Ok(Nil)\n/// ```\n///\n/// ```gleam\n/// replace(Error(1), Nil)\n/// // -> Error(1)\n/// ```\n///\npub fn replace(result: Result(a, e), value: b) -> Result(b, e) {\n  case result {\n    Ok(_) -> Ok(value)\n    Error(error) -> Error(error)\n  }\n}\n\n/// Replace the error within a result\n///\n/// ## Examples\n///\n/// ```gleam\n/// replace_error(Error(1), Nil)\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// replace_error(Ok(1), Nil)\n/// // -> Ok(1)\n/// ```\n///\npub fn replace_error(result: Result(a, e), error: f) -> Result(a, f) {\n  case result {\n    Ok(x) -> Ok(x)\n    Error(_) -> Error(error)\n  }\n}\n\n/// Given a list of results, returns only the values inside `Ok`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// values([Ok(1), Error(\"a\"), Ok(3)])\n/// // -> [1, 3]\n/// ```\n///\npub fn values(results: List(Result(a, e))) -> List(a) {\n  list.filter_map(results, fn(result) { result })\n}\n\n/// Updates a value held within the `Error` of a result by calling a given function\n/// on it, where the given function also returns a result. The two results are\n/// then merged together into one result.\n///\n/// If the result is an `Ok` rather than `Error` the function is not called and the\n/// result stays the same.\n///\n/// This function is useful for chaining together computations that may fail\n/// and trying to recover from possible errors.\n///\n/// If you do not need access to the initial error value, use `result.lazy_or`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// Ok(1) |> try_recover(with: fn(_) { Error(\"failed to recover\") })\n/// // -> Ok(1)\n/// ```\n///\n/// ```gleam\n/// Error(1) |> try_recover(with: fn(error) { Ok(error + 1) })\n/// // -> Ok(2)\n/// ```\n///\n/// ```gleam\n/// Error(1) |> try_recover(with: fn(error) { Error(\"failed to recover\") })\n/// // -> Error(\"failed to recover\")\n/// ```\n///\npub fn try_recover(\n  result: Result(a, e),\n  with fun: fn(e) -> Result(a, f),\n) -> Result(a, f) {\n  case result {\n    Ok(value) -> Ok(value)\n    Error(error) -> fun(error)\n  }\n}\n","gleam/set":"import gleam/dict.{type Dict}\nimport gleam/list\nimport gleam/result\n\n// A list is used as the dict value as an empty list has the smallest\n// representation in Erlang's binary format\n@target(erlang)\ntype Token =\n  List(Nil)\n\n@target(erlang)\nconst token = []\n\n@target(javascript)\ntype Token =\n  Nil\n\n@target(javascript)\nconst token = Nil\n\n/// A set is a collection of unique members of the same type.\n///\n/// It is implemented using the `gleam/dict` module, so inserts and lookups have\n/// logarithmic time complexity.\n///\npub opaque type Set(member) {\n  Set(dict: Dict(member, Token))\n}\n\n/// Creates a new empty set.\n///\npub fn new() -> Set(member) {\n  Set(dict.new())\n}\n\n/// Gets the number of members in a set.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new()\n/// |> insert(1)\n/// |> insert(2)\n/// |> size\n/// // -> 2\n/// ```\n///\npub fn size(set: Set(member)) -> Int {\n  dict.size(set.dict)\n}\n\n/// Determines whether or not the set is empty.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new() |> is_empty\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// new() |> insert(1) |> is_empty\n/// // -> False\n/// ```\n///\npub fn is_empty(set: Set(member)) -> Bool {\n  set == new()\n}\n\n/// Inserts a member into the set.\n///\n/// This function runs in logarithmic time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new()\n/// |> insert(1)\n/// |> insert(2)\n/// |> size\n/// // -> 2\n/// ```\n///\npub fn insert(into set: Set(member), this member: member) -> Set(member) {\n  Set(dict: dict.insert(set.dict, member, token))\n}\n\n/// Checks whether a set contains a given member.\n///\n/// This function runs in logarithmic time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new()\n/// |> insert(2)\n/// |> contains(2)\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// new()\n/// |> insert(2)\n/// |> contains(1)\n/// // -> False\n/// ```\n///\npub fn contains(in set: Set(member), this member: member) -> Bool {\n  set.dict\n  |> dict.get(member)\n  |> result.is_ok\n}\n\n/// Removes a member from a set. If the set does not contain the member then\n/// the set is returned unchanged.\n///\n/// This function runs in logarithmic time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new()\n/// |> insert(2)\n/// |> delete(2)\n/// |> contains(1)\n/// // -> False\n/// ```\n///\npub fn delete(from set: Set(member), this member: member) -> Set(member) {\n  Set(dict: dict.delete(set.dict, member))\n}\n\n/// Converts the set into a list of the contained members.\n///\n/// The list has no specific ordering, any unintentional ordering may change in\n/// future versions of Gleam or Erlang.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// new() |> insert(2) |> to_list\n/// // -> [2]\n/// ```\n///\npub fn to_list(set: Set(member)) -> List(member) {\n  dict.keys(set.dict)\n}\n\n/// Creates a new set of the members in a given list.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// import gleam/int\n/// import gleam/list\n///\n/// [1, 1, 2, 4, 3, 2] |> from_list |> to_list |> list.sort(by: int.compare)\n/// // -> [1, 2, 3, 4]\n/// ```\n///\npub fn from_list(members: List(member)) -> Set(member) {\n  let dict =\n    list.fold(over: members, from: dict.new(), with: fn(m, k) {\n      dict.insert(m, k, token)\n    })\n  Set(dict)\n}\n\n/// Combines all entries into a single value by calling a given function on each\n/// one.\n///\n/// Sets are not ordered so the values are not returned in any specific order.\n/// Do not write code that relies on the order entries are used by this\n/// function as it may change in later versions of Gleam or Erlang.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([1, 3, 9])\n/// |> fold(0, fn(accumulator, member) { accumulator + member })\n/// // -> 13\n/// ```\n///\npub fn fold(\n  over set: Set(member),\n  from initial: acc,\n  with reducer: fn(acc, member) -> acc,\n) -> acc {\n  dict.fold(over: set.dict, from: initial, with: fn(a, k, _) { reducer(a, k) })\n}\n\n/// Creates a new set from an existing set, minus any members that a given\n/// function returns `False` for.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// import gleam/int\n///\n/// from_list([1, 4, 6, 3, 675, 44, 67])\n/// |> filter(keeping: int.is_even)\n/// |> to_list\n/// // -> [4, 6, 44]\n/// ```\n///\npub fn filter(\n  in set: Set(member),\n  keeping predicate: fn(member) -> Bool,\n) -> Set(member) {\n  Set(dict.filter(in: set.dict, keeping: fn(m, _) { predicate(m) }))\n}\n\n/// Creates a new set from a given set with the result of applying the given\n/// function to each member.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([1, 2, 3, 4])\n/// |> map(with: fn(x) { x * 2 })\n/// |> to_list\n/// // -> [2, 4, 6, 8]\n/// ```\n///\npub fn map(set: Set(member), with fun: fn(member) -> mapped) -> Set(mapped) {\n  fold(over: set, from: new(), with: fn(acc, member) {\n    insert(acc, fun(member))\n  })\n}\n\n/// Creates a new set from a given set with all the same entries except any\n/// entry found on the given list.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([1, 2, 3, 4])\n/// |> drop([1, 3])\n/// |> to_list\n/// // -> [2, 4]\n/// ```\n///\npub fn drop(from set: Set(member), drop disallowed: List(member)) -> Set(member) {\n  list.fold(over: disallowed, from: set, with: delete)\n}\n\n/// Creates a new set from a given set, only including any members which are in\n/// a given list.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_list([1, 2, 3])\n/// |> take([1, 3, 5])\n/// |> to_list\n/// // -> [1, 3]\n/// ```\n///\npub fn take(from set: Set(member), keeping desired: List(member)) -> Set(member) {\n  Set(dict.take(from: set.dict, keeping: desired))\n}\n\n/// Creates a new set that contains all members of both given sets.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// union(from_list([1, 2]), from_list([2, 3])) |> to_list\n/// // -> [1, 2, 3]\n/// ```\n///\npub fn union(of first: Set(member), and second: Set(member)) -> Set(member) {\n  let #(larger, smaller) = order(first, second)\n  fold(over: smaller, from: larger, with: insert)\n}\n\nfn order(first: Set(member), second: Set(member)) -> #(Set(member), Set(member)) {\n  case dict.size(first.dict) > dict.size(second.dict) {\n    True -> #(first, second)\n    False -> #(second, first)\n  }\n}\n\n/// Creates a new set that contains members that are present in both given sets.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// intersection(from_list([1, 2]), from_list([2, 3])) |> to_list\n/// // -> [2]\n/// ```\n///\npub fn intersection(\n  of first: Set(member),\n  and second: Set(member),\n) -> Set(member) {\n  let #(larger, smaller) = order(first, second)\n  take(from: larger, keeping: to_list(smaller))\n}\n\n/// Creates a new set that contains members that are present in the first set\n/// but not the second.\n///\n/// ## Examples\n///\n/// ```gleam\n/// difference(from_list([1, 2]), from_list([2, 3, 4])) |> to_list\n/// // -> [1]\n/// ```\n///\npub fn difference(\n  from first: Set(member),\n  minus second: Set(member),\n) -> Set(member) {\n  drop(from: first, drop: to_list(second))\n}\n\n/// Determines if a set is fully contained by another.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_subset(from_list([1]), from_list([1, 2]))\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// is_subset(from_list([1, 2, 3]), from_list([3, 4, 5]))\n/// // -> False\n/// ```\n///\npub fn is_subset(first: Set(member), of second: Set(member)) -> Bool {\n  intersection(of: first, and: second) == first\n}\n\n/// Determines if two sets contain no common members\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_disjoint(from_list([1, 2, 3]), from_list([4, 5, 6]))\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// is_disjoint(from_list([1, 2, 3]), from_list([3, 4, 5]))\n/// // -> False\n/// ```\n///\npub fn is_disjoint(first: Set(member), from second: Set(member)) -> Bool {\n  intersection(of: first, and: second) == new()\n}\n\n/// Creates a new set that contains members that are present in either set, but\n/// not both.\n///\n/// ## Examples\n///\n/// ```gleam\n/// symmetric_difference(from_list([1, 2, 3]), from_list([3, 4])) |> to_list\n/// // -> [1, 2, 4]\n/// ```\n///\npub fn symmetric_difference(\n  of first: Set(member),\n  and second: Set(member),\n) -> Set(member) {\n  difference(\n    from: union(of: first, and: second),\n    minus: intersection(of: first, and: second),\n  )\n}\n\n/// Calls a function for each member in a set, discarding the return\n/// value.\n///\n/// Useful for producing a side effect for every item of a set.\n///\n/// The order of elements in the iteration is an implementation detail that\n/// should not be relied upon.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let set = from_list([\"apple\", \"banana\", \"cherry\"])\n///\n/// each(set, io.println)\n/// // -> Nil\n/// // apple\n/// // banana\n/// // cherry\n/// ```\n///\npub fn each(set: Set(member), fun: fn(member) -> a) -> Nil {\n  fold(set, Nil, fn(nil, member) {\n    fun(member)\n    nil\n  })\n}\n","gleam/string":"//// Strings in Gleam are UTF-8 binaries. They can be written in your code as\n//// text surrounded by `\"double quotes\"`.\n\nimport gleam/list\nimport gleam/option.{type Option, None, Some}\nimport gleam/order\nimport gleam/string_tree.{type StringTree}\n\n/// Determines if a `String` is empty.\n///\n/// ## Examples\n///\n/// ```gleam\n/// is_empty(\"\")\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// is_empty(\"the world\")\n/// // -> False\n/// ```\n///\npub fn is_empty(str: String) -> Bool {\n  str == \"\"\n}\n\n/// Gets the number of grapheme clusters in a given `String`.\n///\n/// This function has to iterate across the whole string to count the number of\n/// graphemes, so it runs in linear time. Avoid using this in a loop.\n///\n/// ## Examples\n///\n/// ```gleam\n/// length(\"Gleam\")\n/// // -> 5\n/// ```\n///\n/// ```gleam\n/// length(\"ß↑e̊\")\n/// // -> 3\n/// ```\n///\n/// ```gleam\n/// length(\"\")\n/// // -> 0\n/// ```\n///\n@external(erlang, \"string\", \"length\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"string_length\")\npub fn length(string: String) -> Int\n\n/// Reverses a `String`.\n///\n/// This function has to iterate across the whole `String` so it runs in linear\n/// time. Avoid using this in a loop.\n///\n/// ## Examples\n///\n/// ```gleam\n/// reverse(\"stressed\")\n/// // -> \"desserts\"\n/// ```\n///\npub fn reverse(string: String) -> String {\n  string\n  |> string_tree.from_string\n  |> string_tree.reverse\n  |> string_tree.to_string\n}\n\n/// Creates a new `String` by replacing all occurrences of a given substring.\n///\n/// ## Examples\n///\n/// ```gleam\n/// replace(\"www.example.com\", each: \".\", with: \"-\")\n/// // -> \"www-example-com\"\n/// ```\n///\n/// ```gleam\n/// replace(\"a,b,c,d,e\", each: \",\", with: \"/\")\n/// // -> \"a/b/c/d/e\"\n/// ```\n///\npub fn replace(\n  in string: String,\n  each pattern: String,\n  with substitute: String,\n) -> String {\n  string\n  |> string_tree.from_string\n  |> string_tree.replace(each: pattern, with: substitute)\n  |> string_tree.to_string\n}\n\n/// Creates a new `String` with all the graphemes in the input `String` converted to\n/// lowercase.\n///\n/// Useful for case-insensitive comparisons.\n///\n/// ## Examples\n///\n/// ```gleam\n/// lowercase(\"X-FILES\")\n/// // -> \"x-files\"\n/// ```\n///\n@external(erlang, \"string\", \"lowercase\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"lowercase\")\npub fn lowercase(string: String) -> String\n\n/// Creates a new `String` with all the graphemes in the input `String` converted to\n/// uppercase.\n///\n/// Useful for case-insensitive comparisons and VIRTUAL YELLING.\n///\n/// ## Examples\n///\n/// ```gleam\n/// uppercase(\"skinner\")\n/// // -> \"SKINNER\"\n/// ```\n///\n@external(erlang, \"string\", \"uppercase\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"uppercase\")\npub fn uppercase(string: String) -> String\n\n/// Compares two `String`s to see which is \"larger\" by comparing their graphemes.\n///\n/// This does not compare the size or length of the given `String`s.\n///\n/// ## Examples\n///\n/// ```gleam\n/// compare(\"Anthony\", \"Anthony\")\n/// // -> order.Eq\n/// ```\n///\n/// ```gleam\n/// compare(\"A\", \"B\")\n/// // -> order.Lt\n/// ```\n///\npub fn compare(a: String, b: String) -> order.Order {\n  case a == b {\n    True -> order.Eq\n    _ ->\n      case less_than(a, b) {\n        True -> order.Lt\n        False -> order.Gt\n      }\n  }\n}\n\n@external(erlang, \"gleam_stdlib\", \"less_than\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"less_than\")\nfn less_than(a: String, b: String) -> Bool\n\n/// Takes a substring given a start grapheme index and a length. Negative indexes\n/// are taken starting from the *end* of the string.\n///\n/// This function runs in linear time with the size of the index and the\n/// length. Negative indexes are linear with the size of the input string in\n/// addition to the other costs.\n///\n/// ## Examples\n///\n/// ```gleam\n/// slice(from: \"gleam\", at_index: 1, length: 2)\n/// // -> \"le\"\n/// ```\n///\n/// ```gleam\n/// slice(from: \"gleam\", at_index: 1, length: 10)\n/// // -> \"leam\"\n/// ```\n///\n/// ```gleam\n/// slice(from: \"gleam\", at_index: 10, length: 3)\n/// // -> \"\"\n/// ```\n///\n/// ```gleam\n/// slice(from: \"gleam\", at_index: -2, length: 2)\n/// // -> \"am\"\n/// ```\n///\n/// ```gleam\n/// slice(from: \"gleam\", at_index: -12, length: 2)\n/// // -> \"\"\n/// ```\n///\npub fn slice(from string: String, at_index idx: Int, length len: Int) -> String {\n  case len <= 0 {\n    True -> \"\"\n    False ->\n      case idx < 0 {\n        True -> {\n          let translated_idx = length(string) + idx\n          case translated_idx < 0 {\n            True -> \"\"\n            False -> grapheme_slice(string, translated_idx, len)\n          }\n        }\n        False -> grapheme_slice(string, idx, len)\n      }\n  }\n}\n\n@external(erlang, \"gleam_stdlib\", \"slice\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"string_grapheme_slice\")\nfn grapheme_slice(string: String, index: Int, length: Int) -> String\n\n@external(erlang, \"binary\", \"part\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"string_byte_slice\")\nfn unsafe_byte_slice(string: String, index: Int, length: Int) -> String\n\n/// Drops contents of the first `String` that occur before the second `String`.\n/// If the `from` string does not contain the `before` string, `from` is\n/// returned unchanged.\n///\n/// ## Examples\n///\n/// ```gleam\n/// crop(from: \"The Lone Gunmen\", before: \"Lone\")\n/// // -> \"Lone Gunmen\"\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"crop_string\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"crop_string\")\npub fn crop(from string: String, before substring: String) -> String\n\n/// Drops *n* graphemes from the start of a `String`.\n///\n/// This function runs in linear time with the number of graphemes to drop.\n///\n/// ## Examples\n///\n/// ```gleam\n/// drop_start(from: \"The Lone Gunmen\", up_to: 2)\n/// // -> \"e Lone Gunmen\"\n/// ```\n///\npub fn drop_start(from string: String, up_to num_graphemes: Int) -> String {\n  case num_graphemes <= 0 {\n    True -> string\n    False -> {\n      let prefix = grapheme_slice(string, 0, num_graphemes)\n      let prefix_size = byte_size(prefix)\n      unsafe_byte_slice(string, prefix_size, byte_size(string) - prefix_size)\n    }\n  }\n}\n\n/// Drops *n* graphemes from the end of a `String`.\n///\n/// This function traverses the full string, so it runs in linear time with the\n/// size of the string. Avoid using this in a loop.\n///\n/// ## Examples\n///\n/// ```gleam\n/// drop_end(from: \"Cigarette Smoking Man\", up_to: 2)\n/// // -> \"Cigarette Smoking M\"\n/// ```\n///\npub fn drop_end(from string: String, up_to num_graphemes: Int) -> String {\n  case num_graphemes <= 0 {\n    True -> string\n    False -> slice(string, 0, length(string) - num_graphemes)\n  }\n}\n\n/// Checks if the first `String` contains the second.\n///\n/// ## Examples\n///\n/// ```gleam\n/// contains(does: \"theory\", contain: \"ory\")\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// contains(does: \"theory\", contain: \"the\")\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// contains(does: \"theory\", contain: \"THE\")\n/// // -> False\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"contains_string\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"contains_string\")\npub fn contains(does haystack: String, contain needle: String) -> Bool\n\n/// Checks whether the first `String` starts with the second one.\n///\n/// ## Examples\n///\n/// ```gleam\n/// starts_with(\"theory\", \"ory\")\n/// // -> False\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"string_starts_with\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"starts_with\")\npub fn starts_with(string: String, prefix: String) -> Bool\n\n/// Checks whether the first `String` ends with the second one.\n///\n/// ## Examples\n///\n/// ```gleam\n/// ends_with(\"theory\", \"ory\")\n/// // -> True\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"string_ends_with\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"ends_with\")\npub fn ends_with(string: String, suffix: String) -> Bool\n\n/// Creates a list of `String`s by splitting a given string on a given substring.\n///\n/// ## Examples\n///\n/// ```gleam\n/// split(\"home/gleam/desktop/\", on: \"/\")\n/// // -> [\"home\", \"gleam\", \"desktop\", \"\"]\n/// ```\n///\npub fn split(x: String, on substring: String) -> List(String) {\n  case substring {\n    \"\" -> to_graphemes(x)\n    _ ->\n      x\n      |> string_tree.from_string\n      |> string_tree.split(on: substring)\n      |> list.map(with: string_tree.to_string)\n  }\n}\n\n/// Splits a `String` a single time on the given substring.\n///\n/// Returns an `Error` if substring not present.\n///\n/// ## Examples\n///\n/// ```gleam\n/// split_once(\"home/gleam/desktop/\", on: \"/\")\n/// // -> Ok(#(\"home\", \"gleam/desktop/\"))\n/// ```\n///\n/// ```gleam\n/// split_once(\"home/gleam/desktop/\", on: \"?\")\n/// // -> Error(Nil)\n/// ```\n///\n@external(javascript, \"../gleam_stdlib.mjs\", \"split_once\")\npub fn split_once(\n  string: String,\n  on substring: String,\n) -> Result(#(String, String), Nil) {\n  case erl_split(string, substring) {\n    [first, rest] -> Ok(#(first, rest))\n    _ -> Error(Nil)\n  }\n}\n\n@external(erlang, \"string\", \"split\")\nfn erl_split(a: String, b: String) -> List(String)\n\n/// Creates a new `String` by joining two `String`s together.\n///\n/// This function typically copies both `String`s and runs in linear time, but\n/// the exact behaviour will depend on how the runtime you are using optimises\n/// your code. Benchmark and profile your code if you need to understand its\n/// performance better.\n///\n/// If you are joining together large string and want to avoid copying any data\n/// you may want to investigate using the [`string_tree`](../gleam/string_tree.html)\n/// module.\n///\n/// ## Examples\n///\n/// ```gleam\n/// append(to: \"butter\", suffix: \"fly\")\n/// // -> \"butterfly\"\n/// ```\n///\npub fn append(to first: String, suffix second: String) -> String {\n  first <> second\n}\n\n/// Creates a new `String` by joining many `String`s together.\n///\n/// This function copies all the `String`s and runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// concat([\"never\", \"the\", \"less\"])\n/// // -> \"nevertheless\"\n/// ```\n///\n@external(erlang, \"erlang\", \"list_to_binary\")\npub fn concat(strings: List(String)) -> String {\n  concat_loop(strings, \"\")\n}\n\nfn concat_loop(strings: List(String), accumulator: String) -> String {\n  case strings {\n    [string, ..strings] -> concat_loop(strings, accumulator <> string)\n    [] -> accumulator\n  }\n}\n\n/// Creates a new `String` by repeating a `String` a given number of times.\n///\n/// This function runs in loglinear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// repeat(\"ha\", times: 3)\n/// // -> \"hahaha\"\n/// ```\n///\npub fn repeat(string: String, times times: Int) -> String {\n  case times <= 0 {\n    True -> \"\"\n    False -> repeat_loop(times, string, \"\")\n  }\n}\n\nfn repeat_loop(times: Int, doubling_acc: String, acc: String) -> String {\n  let acc = case times % 2 {\n    0 -> acc\n    _ -> acc <> doubling_acc\n  }\n  let times = times / 2\n  case times <= 0 {\n    True -> acc\n    False -> repeat_loop(times, doubling_acc <> doubling_acc, acc)\n  }\n}\n\n/// Joins many `String`s together with a given separator.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n/// ```gleam\n/// join([\"home\",\"evan\",\"Desktop\"], with: \"/\")\n/// // -> \"home/evan/Desktop\"\n/// ```\n///\npub fn join(strings: List(String), with separator: String) -> String {\n  case strings {\n    [] -> \"\"\n    [first, ..rest] -> join_loop(rest, separator, first)\n  }\n}\n\nfn join_loop(\n  strings: List(String),\n  separator: String,\n  accumulator: String,\n) -> String {\n  case strings {\n    [] -> accumulator\n    [string, ..strings] ->\n      join_loop(strings, separator, accumulator <> separator <> string)\n  }\n}\n\n/// Pads the start of a `String` until it has a given length.\n///\n/// ## Examples\n///\n/// ```gleam\n/// pad_start(\"121\", to: 5, with: \".\")\n/// // -> \"..121\"\n/// ```\n///\n/// ```gleam\n/// pad_start(\"121\", to: 3, with: \".\")\n/// // -> \"121\"\n/// ```\n///\n/// ```gleam\n/// pad_start(\"121\", to: 2, with: \".\")\n/// // -> \"121\"\n/// ```\n///\npub fn pad_start(\n  string: String,\n  to desired_length: Int,\n  with pad_string: String,\n) -> String {\n  let current_length = length(string)\n  let to_pad_length = desired_length - current_length\n\n  case to_pad_length <= 0 {\n    True -> string\n    False -> padding(to_pad_length, pad_string) <> string\n  }\n}\n\n/// Pads the end of a `String` until it has a given length.\n///\n/// ## Examples\n///\n/// ```gleam\n/// pad_end(\"123\", to: 5, with: \".\")\n/// // -> \"123..\"\n/// ```\n///\n/// ```gleam\n/// pad_end(\"123\", to: 3, with: \".\")\n/// // -> \"123\"\n/// ```\n///\n/// ```gleam\n/// pad_end(\"123\", to: 2, with: \".\")\n/// // -> \"123\"\n/// ```\n///\npub fn pad_end(\n  string: String,\n  to desired_length: Int,\n  with pad_string: String,\n) -> String {\n  let current_length = length(string)\n  let to_pad_length = desired_length - current_length\n\n  case to_pad_length <= 0 {\n    True -> string\n    False -> string <> padding(to_pad_length, pad_string)\n  }\n}\n\nfn padding(size: Int, pad_string: String) -> String {\n  let pad_string_length = length(pad_string)\n  let num_pads = size / pad_string_length\n  let extra = size % pad_string_length\n\n  repeat(pad_string, num_pads) <> slice(pad_string, 0, extra)\n}\n\n/// Removes whitespace on both sides of a `String`.\n///\n/// Whitespace in this function is the set of nonbreakable whitespace\n/// codepoints, defined as Pattern_White_Space in [Unicode Standard Annex #31][1].\n///\n/// [1]: https://unicode.org/reports/tr31/\n///\n/// ## Examples\n///\n/// ```gleam\n/// trim(\"  hats  \\n\")\n/// // -> \"hats\"\n/// ```\n///\npub fn trim(string: String) -> String {\n  string |> trim_start |> trim_end\n}\n\n@external(erlang, \"string\", \"trim\")\nfn erl_trim(a: String, b: Direction) -> String\n\ntype Direction {\n  Leading\n  Trailing\n}\n\n/// Removes whitespace at the start of a `String`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// trim_start(\"  hats  \\n\")\n/// // -> \"hats  \\n\"\n/// ```\n///\n@external(javascript, \"../gleam_stdlib.mjs\", \"trim_start\")\npub fn trim_start(string: String) -> String {\n  erl_trim(string, Leading)\n}\n\n/// Removes whitespace at the end of a `String`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// trim_end(\"  hats  \\n\")\n/// // -> \"  hats\"\n/// ```\n///\n@external(javascript, \"../gleam_stdlib.mjs\", \"trim_end\")\npub fn trim_end(string: String) -> String {\n  erl_trim(string, Trailing)\n}\n\n/// Splits a non-empty `String` into its first element (head) and rest (tail).\n/// This lets you pattern match on `String`s exactly as you would with lists.\n///\n/// ## Performance\n///\n/// There is a notable overhead to using this function, so you may not want to\n/// use it in a tight loop. If you wish to efficiently parse a string you may\n/// want to use alternatives such as the [splitter package](https://hex.pm/packages/splitter).\n///\n/// ## Examples\n///\n/// ```gleam\n/// pop_grapheme(\"gleam\")\n/// // -> Ok(#(\"g\", \"leam\"))\n/// ```\n///\n/// ```gleam\n/// pop_grapheme(\"\")\n/// // -> Error(Nil)\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"string_pop_grapheme\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"pop_grapheme\")\npub fn pop_grapheme(string: String) -> Result(#(String, String), Nil)\n\n/// Converts a `String` to a list of\n/// [graphemes](https://en.wikipedia.org/wiki/Grapheme).\n///\n/// ```gleam\n/// to_graphemes(\"abc\")\n/// // -> [\"a\", \"b\", \"c\"]\n/// ```\n///\n@external(javascript, \"../gleam_stdlib.mjs\", \"graphemes\")\npub fn to_graphemes(string: String) -> List(String) {\n  string\n  |> to_graphemes_loop([])\n  |> list.reverse\n}\n\nfn to_graphemes_loop(string: String, acc: List(String)) -> List(String) {\n  case pop_grapheme(string) {\n    Ok(#(grapheme, rest)) -> to_graphemes_loop(rest, [grapheme, ..acc])\n    Error(_) -> acc\n  }\n}\n\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"codepoint\")\nfn unsafe_int_to_utf_codepoint(a: Int) -> UtfCodepoint\n\n/// Converts a `String` to a `List` of `UtfCodepoint`.\n///\n/// See <https://en.wikipedia.org/wiki/Code_point> and\n/// <https://en.wikipedia.org/wiki/Unicode#Codespace_and_Code_Points> for an\n/// explanation on code points.\n///\n/// ## Examples\n///\n/// ```gleam\n/// \"a\" |> to_utf_codepoints\n/// // -> [UtfCodepoint(97)]\n/// ```\n///\n/// ```gleam\n/// // Semantically the same as:\n/// // [\"🏳\", \"️\", \"‍\", \"🌈\"] or:\n/// // [waving_white_flag, variant_selector_16, zero_width_joiner, rainbow]\n/// \"🏳️‍🌈\" |> to_utf_codepoints\n/// // -> [\n/// //   UtfCodepoint(127987),\n/// //   UtfCodepoint(65039),\n/// //   UtfCodepoint(8205),\n/// //   UtfCodepoint(127752),\n/// // ]\n/// ```\n///\npub fn to_utf_codepoints(string: String) -> List(UtfCodepoint) {\n  do_to_utf_codepoints(string)\n}\n\n@target(erlang)\nfn do_to_utf_codepoints(string: String) -> List(UtfCodepoint) {\n  to_utf_codepoints_loop(<<string:utf8>>, [])\n}\n\n@target(erlang)\nfn to_utf_codepoints_loop(\n  bit_array: BitArray,\n  acc: List(UtfCodepoint),\n) -> List(UtfCodepoint) {\n  case bit_array {\n    <<first:utf8_codepoint, rest:bytes>> ->\n      to_utf_codepoints_loop(rest, [first, ..acc])\n    _ -> list.reverse(acc)\n  }\n}\n\n@target(javascript)\nfn do_to_utf_codepoints(string: String) -> List(UtfCodepoint) {\n  string\n  |> string_to_codepoint_integer_list\n  |> list.map(unsafe_int_to_utf_codepoint)\n}\n\n@target(javascript)\n@external(javascript, \"../gleam_stdlib.mjs\", \"string_to_codepoint_integer_list\")\nfn string_to_codepoint_integer_list(string: String) -> List(Int)\n\n/// Converts a `List` of `UtfCodepoint`s to a `String`.\n///\n/// See <https://en.wikipedia.org/wiki/Code_point> and\n/// <https://en.wikipedia.org/wiki/Unicode#Codespace_and_Code_Points> for an\n/// explanation on code points.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let assert Ok(a) = utf_codepoint(97)\n/// let assert Ok(b) = utf_codepoint(98)\n/// let assert Ok(c) = utf_codepoint(99)\n/// from_utf_codepoints([a, b, c])\n/// // -> \"abc\"\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"utf_codepoint_list_to_string\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"utf_codepoint_list_to_string\")\npub fn from_utf_codepoints(utf_codepoints: List(UtfCodepoint)) -> String\n\n/// Converts an integer to a `UtfCodepoint`.\n///\n/// Returns an `Error` if the integer does not represent a valid UTF codepoint.\n///\npub fn utf_codepoint(value: Int) -> Result(UtfCodepoint, Nil) {\n  case value {\n    i if i > 1_114_111 -> Error(Nil)\n    i if i >= 55_296 && i <= 57_343 -> Error(Nil)\n    i if i < 0 -> Error(Nil)\n    i -> Ok(unsafe_int_to_utf_codepoint(i))\n  }\n}\n\n/// Converts a `UtfCodepoint` to its ordinal code point value.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let assert [utf_codepoint, ..] = to_utf_codepoints(\"💜\")\n/// utf_codepoint_to_int(utf_codepoint)\n/// // -> 128156\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"utf_codepoint_to_int\")\npub fn utf_codepoint_to_int(cp: UtfCodepoint) -> Int\n\n/// Converts a `String` into `Option(String)` where an empty `String` becomes\n/// `None`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// to_option(\"\")\n/// // -> None\n/// ```\n///\n/// ```gleam\n/// to_option(\"hats\")\n/// // -> Some(\"hats\")\n/// ```\n///\npub fn to_option(string: String) -> Option(String) {\n  case string {\n    \"\" -> None\n    _ -> Some(string)\n  }\n}\n\n/// Returns the first grapheme cluster in a given `String` and wraps it in a\n/// `Result(String, Nil)`. If the `String` is empty, it returns `Error(Nil)`.\n/// Otherwise, it returns `Ok(String)`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// first(\"\")\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// first(\"icecream\")\n/// // -> Ok(\"i\")\n/// ```\n///\npub fn first(string: String) -> Result(String, Nil) {\n  case pop_grapheme(string) {\n    Ok(#(first, _)) -> Ok(first)\n    Error(e) -> Error(e)\n  }\n}\n\n/// Returns the last grapheme cluster in a given `String` and wraps it in a\n/// `Result(String, Nil)`. If the `String` is empty, it returns `Error(Nil)`.\n/// Otherwise, it returns `Ok(String)`.\n///\n/// This function traverses the full string, so it runs in linear time with the\n/// length of the string. Avoid using this in a loop.\n///\n/// ## Examples\n///\n/// ```gleam\n/// last(\"\")\n/// // -> Error(Nil)\n/// ```\n///\n/// ```gleam\n/// last(\"icecream\")\n/// // -> Ok(\"m\")\n/// ```\n///\npub fn last(string: String) -> Result(String, Nil) {\n  case pop_grapheme(string) {\n    Ok(#(first, \"\")) -> Ok(first)\n    Ok(#(_, rest)) -> Ok(slice(rest, -1, 1))\n    Error(e) -> Error(e)\n  }\n}\n\n/// Creates a new `String` with the first grapheme in the input `String`\n/// converted to uppercase and the remaining graphemes to lowercase.\n///\n/// ## Examples\n///\n/// ```gleam\n/// capitalise(\"mamouna\")\n/// // -> \"Mamouna\"\n/// ```\n///\npub fn capitalise(string: String) -> String {\n  case pop_grapheme(string) {\n    Ok(#(first, rest)) -> append(to: uppercase(first), suffix: lowercase(rest))\n    Error(_) -> \"\"\n  }\n}\n\n/// Returns a `String` representation of a term in Gleam syntax.\n///\n/// This may be occasionally useful for quick-and-dirty printing of values in\n/// scripts. For error reporting and other uses prefer constructing strings by\n/// pattern matching on the values.\n///\n/// ## Limitations\n///\n/// The output format of this function is not stable and could change at any\n/// time. The output is not suitable for parsing.\n///\n/// This function works using runtime reflection, so the output may not be\n/// perfectly accurate for data structures where the runtime structure doesn't\n/// hold enough information to determine the original syntax. For example,\n/// tuples with an Erlang atom in the first position will be mistaken for Gleam\n/// records.\n///\n/// ## Security and safety\n///\n/// There is no limit to how large the strings that this function can produce.\n/// Be careful not to call this function with large data structures or you\n/// could use very large amounts of memory, potentially causing runtime\n/// problems.\n///\npub fn inspect(term: anything) -> String {\n  term\n  |> do_inspect\n  |> string_tree.to_string\n}\n\n@external(erlang, \"gleam_stdlib\", \"inspect\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"inspect\")\nfn do_inspect(term: anything) -> StringTree\n\n/// Returns the number of bytes in a `String`.\n///\n/// This function runs in constant time on Erlang and in linear time on\n/// JavaScript.\n///\n/// ## Examples\n///\n/// ```gleam\n/// byte_size(\"🏳️‍⚧️🏳️‍🌈👩🏾‍❤️‍👨🏻\")\n/// // -> 58\n/// ```\n///\n@external(erlang, \"erlang\", \"byte_size\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"byte_size\")\npub fn byte_size(string: String) -> Int\n","gleam/string_tree":"import gleam/list\n\n/// `StringTree` is a type used for efficiently building text content to be\n/// written to a file or a socket. Internally it is represented as a tree so to\n/// append or prepend to a string tree is a constant time operation that\n/// allocates a new node in the tree without copying any of the content. When\n/// writing to an output stream the tree is traversed and the content is sent\n/// directly rather than copying it into a single buffer beforehand.\n///\n/// On Erlang this type is compatible with Erlang's iodata. On JavaScript this\n/// type is compatible with normal strings.\n///\n/// The BEAM virtual machine has an optimisation for appending strings, where it\n/// will mutate the string buffer when safe to do so, so if you are looking to\n/// build a string through appending many small strings then you may get better\n/// performance by not using a string tree. Always benchmark your performance\n/// sensitive code.\n///\npub type StringTree\n\n/// Create an empty `StringTree`. Useful as the start of a pipe chaining many\n/// trees together.\n///\npub fn new() -> StringTree {\n  from_strings([])\n}\n\n/// Prepends a `String` onto the start of some `StringTree`.\n///\n/// Runs in constant time.\n///\npub fn prepend(to tree: StringTree, prefix prefix: String) -> StringTree {\n  append_tree(from_string(prefix), tree)\n}\n\n/// Appends a `String` onto the end of some `StringTree`.\n///\n/// Runs in constant time.\n///\npub fn append(to tree: StringTree, suffix second: String) -> StringTree {\n  append_tree(tree, from_string(second))\n}\n\n/// Prepends some `StringTree` onto the start of another.\n///\n/// Runs in constant time.\n///\npub fn prepend_tree(\n  to tree: StringTree,\n  prefix prefix: StringTree,\n) -> StringTree {\n  append_tree(prefix, tree)\n}\n\n/// Appends some `StringTree` onto the end of another.\n///\n/// Runs in constant time.\n///\n@external(erlang, \"gleam_stdlib\", \"iodata_append\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"add\")\npub fn append_tree(to tree: StringTree, suffix suffix: StringTree) -> StringTree\n\n/// Converts a list of strings into a `StringTree`.\n///\n/// Runs in constant time.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"concat\")\npub fn from_strings(strings: List(String)) -> StringTree\n\n/// Joins a list of trees into a single tree.\n///\n/// Runs in constant time.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"concat\")\npub fn concat(trees: List(StringTree)) -> StringTree\n\n/// Converts a string into a `StringTree`.\n///\n/// Runs in constant time.\n///\n@external(erlang, \"gleam_stdlib\", \"identity\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn from_string(string: String) -> StringTree\n\n/// Turns a `StringTree` into a `String`.\n///\n/// This function is implemented natively by the virtual machine and is highly\n/// optimised.\n///\n@external(erlang, \"unicode\", \"characters_to_binary\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"identity\")\npub fn to_string(tree: StringTree) -> String\n\n/// Returns the size of the `StringTree` in bytes.\n///\n@external(erlang, \"erlang\", \"iolist_size\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"length\")\npub fn byte_size(tree: StringTree) -> Int\n\n/// Joins the given trees into a new tree separated with the given string.\n///\npub fn join(trees: List(StringTree), with sep: String) -> StringTree {\n  trees\n  |> list.intersperse(from_string(sep))\n  |> concat\n}\n\n/// Converts a `StringTree` to a new one where the contents have been\n/// lowercased.\n///\n@external(erlang, \"string\", \"lowercase\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"lowercase\")\npub fn lowercase(tree: StringTree) -> StringTree\n\n/// Converts a `StringTree` to a new one where the contents have been\n/// uppercased.\n///\n@external(erlang, \"string\", \"uppercase\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"uppercase\")\npub fn uppercase(tree: StringTree) -> StringTree\n\n/// Converts a `StringTree` to a new one with the contents reversed.\n///\n@external(erlang, \"string\", \"reverse\")\npub fn reverse(tree: StringTree) -> StringTree {\n  tree\n  |> to_string\n  |> do_to_graphemes\n  |> list.reverse\n  |> from_strings\n}\n\n@external(javascript, \"../gleam_stdlib.mjs\", \"graphemes\")\nfn do_to_graphemes(string: String) -> List(String)\n\ntype Direction {\n  All\n}\n\n/// Splits a `StringTree` on a given pattern into a list of trees.\n///\n@external(javascript, \"../gleam_stdlib.mjs\", \"split\")\npub fn split(tree: StringTree, on pattern: String) -> List(StringTree) {\n  erl_split(tree, pattern, All)\n}\n\n@external(erlang, \"string\", \"split\")\nfn erl_split(a: StringTree, b: String, c: Direction) -> List(StringTree)\n\n/// Replaces all instances of a pattern with a given string substitute.\n///\n@external(erlang, \"gleam_stdlib\", \"string_replace\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"string_replace\")\npub fn replace(\n  in tree: StringTree,\n  each pattern: String,\n  with substitute: String,\n) -> StringTree\n\n/// Compares two string trees to determine if they have the same textual\n/// content.\n///\n/// Comparing two string trees using the `==` operator may return `False` even\n/// if they have the same content as they may have been build in different ways,\n/// so using this function is often preferred.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_strings([\"a\", \"b\"]) == from_string(\"ab\")\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// is_equal(from_strings([\"a\", \"b\"]), from_string(\"ab\"))\n/// // -> True\n/// ```\n///\n@external(erlang, \"string\", \"equal\")\npub fn is_equal(a: StringTree, b: StringTree) -> Bool {\n  a == b\n}\n\n/// Inspects a `StringTree` to determine if it is equivalent to an empty string.\n///\n/// ## Examples\n///\n/// ```gleam\n/// from_string(\"ok\") |> is_empty\n/// // -> False\n/// ```\n///\n/// ```gleam\n/// from_string(\"\") |> is_empty\n/// // -> True\n/// ```\n///\n/// ```gleam\n/// from_strings([]) |> is_empty\n/// // -> True\n/// ```\n///\n@external(erlang, \"string\", \"is_empty\")\npub fn is_empty(tree: StringTree) -> Bool {\n  from_string(\"\") == tree\n}\n","gleam/uri":"//// Utilities for working with URIs\n////\n//// This module provides functions for working with URIs (for example, parsing\n//// URIs or encoding query strings). The functions in this module are implemented\n//// according to [RFC 3986](https://tools.ietf.org/html/rfc3986).\n////\n//// Query encoding (Form encoding) is defined in the\n//// [W3C specification](https://www.w3.org/TR/html52/sec-forms.html#urlencoded-form-data).\n\nimport gleam/int\nimport gleam/list\nimport gleam/option.{type Option, None, Some}\nimport gleam/string\nimport gleam/string_tree.{type StringTree}\n\n/// Type representing the parsed components of an URI.\n/// All components of a URI are optional, except the path.\n///\npub type Uri {\n  Uri(\n    scheme: Option(String),\n    userinfo: Option(String),\n    host: Option(String),\n    port: Option(Int),\n    path: String,\n    query: Option(String),\n    fragment: Option(String),\n  )\n}\n\n/// Constant representing an empty URI, equivalent to \"\".\n///\n/// ## Examples\n///\n/// ```gleam\n/// let uri = Uri(..empty, scheme: Some(\"https\"), host: Some(\"example.com\"))\n/// // -> Uri(\n/// //   scheme: Some(\"https\"),\n/// //   userinfo: None,\n/// //   host: Some(\"example.com\"),\n/// //   port: None,\n/// //   path: \"\",\n/// //   query: None,\n/// //   fragment: None,\n/// // )\n/// ```\n///\npub const empty = Uri(\n  scheme: None,\n  userinfo: None,\n  host: None,\n  port: None,\n  path: \"\",\n  query: None,\n  fragment: None,\n)\n\n/// Parses a compliant URI string into the `Uri` type.\n/// If the string is not a valid URI string then an error is returned.\n///\n/// The opposite operation is `uri.to_string`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// parse(\"https://example.com:1234/a/b?query=true#fragment\")\n/// // -> Ok(\n/// //   Uri(\n/// //     scheme: Some(\"https\"),\n/// //     userinfo: None,\n/// //     host: Some(\"example.com\"),\n/// //     port: Some(1234),\n/// //     path: \"/a/b\",\n/// //     query: Some(\"query=true\"),\n/// //     fragment: Some(\"fragment\")\n/// //   )\n/// // )\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"uri_parse\")\npub fn parse(uri_string: String) -> Result(Uri, Nil) {\n  // This parses a uri_string following the regex defined in\n  // https://tools.ietf.org/html/rfc3986#appendix-B\n  //\n  // TODO: This is not perfect and will be more permissive than its Erlang\n  // counterpart, ideally we want to replicate Erlang's implementation on the js\n  // target as well.\n  parse_scheme_loop(uri_string, uri_string, empty, 0)\n}\n\nfn parse_scheme_loop(\n  original: String,\n  uri_string: String,\n  pieces: Uri,\n  size: Int,\n) -> Result(Uri, Nil) {\n  case uri_string {\n    // `/` is not allowed to appear in a scheme so we know it's over and we can\n    // start parsing the authority with slashes.\n    \"/\" <> _ if size == 0 -> parse_authority_with_slashes(uri_string, pieces)\n    \"/\" <> _ -> {\n      let scheme = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, scheme: Some(string.lowercase(scheme)))\n      parse_authority_with_slashes(uri_string, pieces)\n    }\n\n    // `?` is not allowed to appear in a schemem, in an authority, or in a path;\n    // so if we see it we know it marks the beginning of the query part.\n    \"?\" <> rest if size == 0 -> parse_query_with_question_mark(rest, pieces)\n    \"?\" <> rest -> {\n      let scheme = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, scheme: Some(string.lowercase(scheme)))\n      parse_query_with_question_mark(rest, pieces)\n    }\n\n    // `#` is not allowed to appear in a scheme, in an authority, in a path or\n    // in a query; so if we see it we know it marks the beginning of the final\n    // fragment.\n    \"#\" <> rest if size == 0 -> parse_fragment(rest, pieces)\n    \"#\" <> rest -> {\n      let scheme = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, scheme: Some(string.lowercase(scheme)))\n      parse_fragment(rest, pieces)\n    }\n\n    // A colon marks the end of a uri scheme, but if it is not preceded by any\n    // character then it's not a valid URI.\n    \":\" <> _ if size == 0 -> Error(Nil)\n    \":\" <> rest -> {\n      let scheme = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, scheme: Some(string.lowercase(scheme)))\n      parse_authority_with_slashes(rest, pieces)\n    }\n\n    // If we could get to the end of the string and we've met no special\n    // chars whatsoever, that means the entire string is just a long path.\n    \"\" -> Ok(Uri(..pieces, path: original))\n\n    // In all other cases the first character is just a valid URI scheme\n    // character and we just keep munching characters until we reach the end of\n    // the uri scheme (or the end of the string and that would mean this is not\n    // a valid uri scheme since we found no `:`).\n    _ -> {\n      let #(_, rest) = pop_codeunit(uri_string)\n      parse_scheme_loop(original, rest, pieces, size + 1)\n    }\n  }\n}\n\nfn parse_authority_with_slashes(\n  uri_string: String,\n  pieces: Uri,\n) -> Result(Uri, Nil) {\n  case uri_string {\n    // To be a valid authority the string must start with a `//`, otherwise\n    // there's no authority and we just skip ahead to parsing the path.\n    \"//\" -> Ok(Uri(..pieces, host: Some(\"\")))\n    \"//\" <> rest -> parse_authority_pieces(rest, pieces)\n    _ -> parse_path(uri_string, pieces)\n  }\n}\n\nfn parse_authority_pieces(string: String, pieces: Uri) -> Result(Uri, Nil) {\n  parse_userinfo_loop(string, string, pieces, 0)\n}\n\nfn parse_userinfo_loop(\n  original: String,\n  uri_string: String,\n  pieces: Uri,\n  size: Int,\n) -> Result(Uri, Nil) {\n  case uri_string {\n    // `@` marks the end of the userinfo and the start of the host part in the\n    // authority string.\n    \"@\" <> rest if size == 0 -> parse_host(rest, pieces)\n    \"@\" <> rest -> {\n      let userinfo = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, userinfo: Some(userinfo))\n      parse_host(rest, pieces)\n    }\n\n    // If we reach the end of the authority string without finding an `@`\n    // special character, then we know that the authority doesn't actually\n    // contain the userinfo part.\n    // The entire string we just went through was a host! So we parse it as\n    // such.\n    \"\" | \"/\" <> _ | \"?\" <> _ | \"#\" <> _ -> parse_host(original, pieces)\n\n    // In all other cases we just keep munching characters increasing the size\n    // of the userinfo bit.\n    _ -> {\n      let #(_, rest) = pop_codeunit(uri_string)\n      parse_userinfo_loop(original, rest, pieces, size + 1)\n    }\n  }\n}\n\nfn parse_host(uri_string: String, pieces: Uri) -> Result(Uri, Nil) {\n  // A host string can be in two formats:\n  // - \\[[:.a-zA-Z0-9]*\\]\n  // - [^:]\n  case uri_string {\n    // If we find an opening bracket we know it's the first format.\n    \"[\" <> _ -> parse_host_within_brackets(uri_string, pieces)\n\n    // A `:` marks the beginning of the port part of the authority string.\n    \":\" <> _ -> {\n      let pieces = Uri(..pieces, host: Some(\"\"))\n      parse_port(uri_string, pieces)\n    }\n\n    // If the string is empty then there's no need to keep going. The host is\n    // empty.\n    \"\" -> Ok(Uri(..pieces, host: Some(\"\")))\n\n    // Otherwise it's the second format\n    _ -> parse_host_outside_of_brackets(uri_string, pieces)\n  }\n}\n\nfn parse_host_within_brackets(\n  uri_string: String,\n  pieces: Uri,\n) -> Result(Uri, Nil) {\n  parse_host_within_brackets_loop(uri_string, uri_string, pieces, 0)\n}\n\nfn parse_host_within_brackets_loop(\n  original: String,\n  uri_string: String,\n  pieces: Uri,\n  size: Int,\n) -> Result(Uri, Nil) {\n  case uri_string {\n    // If the string is over the entire string we were iterating through is the\n    // host part.\n    \"\" -> Ok(Uri(..pieces, host: Some(uri_string)))\n\n    // A `]` marks the end of the host and the start of the port part.\n    \"]\" <> rest if size == 0 -> parse_port(rest, pieces)\n    \"]\" <> rest -> {\n      let host = codeunit_slice(original, at_index: 0, length: size + 1)\n      let pieces = Uri(..pieces, host: Some(host))\n      parse_port(rest, pieces)\n    }\n\n    // `/` marks the beginning of a path.\n    \"/\" <> _ if size == 0 -> parse_path(uri_string, pieces)\n    \"/\" <> _ -> {\n      let host = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, host: Some(host))\n      parse_path(uri_string, pieces)\n    }\n\n    // `?` marks the beginning of the query with question mark.\n    \"?\" <> rest if size == 0 -> parse_query_with_question_mark(rest, pieces)\n    \"?\" <> rest -> {\n      let host = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, host: Some(host))\n      parse_query_with_question_mark(rest, pieces)\n    }\n\n    // `#` marks the beginning of the fragment part.\n    \"#\" <> rest if size == 0 -> parse_fragment(rest, pieces)\n    \"#\" <> rest -> {\n      let host = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, host: Some(host))\n      parse_fragment(rest, pieces)\n    }\n\n    // In all other cases we just keep iterating.\n    _ -> {\n      let #(char, rest) = pop_codeunit(uri_string)\n      // Inside `[...]` there can only be some characters, if we find a special\n      // one then we know that we're actually parsing the other format for the\n      // host and we switch to that!\n      case is_valid_host_within_brackets_char(char) {\n        True ->\n          parse_host_within_brackets_loop(original, rest, pieces, size + 1)\n\n        False ->\n          parse_host_outside_of_brackets_loop(original, original, pieces, 0)\n      }\n    }\n  }\n}\n\nfn is_valid_host_within_brackets_char(char: Int) -> Bool {\n  // [0-9]\n  { 48 >= char && char <= 57 }\n  // [A-Z]\n  || { 65 >= char && char <= 90 }\n  // [a-z]\n  || { 97 >= char && char <= 122 }\n  // :\n  || char == 58\n  // .\n  || char == 46\n}\n\nfn parse_host_outside_of_brackets(\n  uri_string: String,\n  pieces: Uri,\n) -> Result(Uri, Nil) {\n  parse_host_outside_of_brackets_loop(uri_string, uri_string, pieces, 0)\n}\n\nfn parse_host_outside_of_brackets_loop(\n  original: String,\n  uri_string: String,\n  pieces: Uri,\n  size: Int,\n) -> Result(Uri, Nil) {\n  case uri_string {\n    \"\" -> Ok(Uri(..pieces, host: Some(original)))\n\n    // `:` marks the beginning of the port.\n    \":\" <> _ -> {\n      let host = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, host: Some(host))\n      parse_port(uri_string, pieces)\n    }\n\n    // `/` marks the beginning of a path.\n    \"/\" <> _ -> {\n      let host = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, host: Some(host))\n      parse_path(uri_string, pieces)\n    }\n\n    // `?` marks the beginning of the query with question mark.\n    \"?\" <> rest -> {\n      let host = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, host: Some(host))\n      parse_query_with_question_mark(rest, pieces)\n    }\n\n    // `#` marks the beginning of the fragment part.\n    \"#\" <> rest -> {\n      let host = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, host: Some(host))\n      parse_fragment(rest, pieces)\n    }\n\n    _ -> {\n      let #(_, rest) = pop_codeunit(uri_string)\n      parse_host_outside_of_brackets_loop(original, rest, pieces, size + 1)\n    }\n  }\n}\n\nfn parse_port(uri_string: String, pieces: Uri) -> Result(Uri, Nil) {\n  case uri_string {\n    \":0\" <> rest -> parse_port_loop(rest, pieces, 0)\n    \":1\" <> rest -> parse_port_loop(rest, pieces, 1)\n    \":2\" <> rest -> parse_port_loop(rest, pieces, 2)\n    \":3\" <> rest -> parse_port_loop(rest, pieces, 3)\n    \":4\" <> rest -> parse_port_loop(rest, pieces, 4)\n    \":5\" <> rest -> parse_port_loop(rest, pieces, 5)\n    \":6\" <> rest -> parse_port_loop(rest, pieces, 6)\n    \":7\" <> rest -> parse_port_loop(rest, pieces, 7)\n    \":8\" <> rest -> parse_port_loop(rest, pieces, 8)\n    \":9\" <> rest -> parse_port_loop(rest, pieces, 9)\n\n    // The port could be empty and be followed by any of the next delimiters.\n    // Like `:#`, `:?` or `:/`\n    \":\" | \"\" -> Ok(pieces)\n\n    // `?` marks the beginning of the query with question mark.\n    \"?\" <> rest | \":?\" <> rest -> parse_query_with_question_mark(rest, pieces)\n\n    // `#` marks the beginning of the fragment part.\n    \"#\" <> rest | \":#\" <> rest -> parse_fragment(rest, pieces)\n\n    // `/` marks the beginning of a path.\n    \"/\" <> _ -> parse_path(uri_string, pieces)\n    \":\" <> rest ->\n      case rest {\n        \"/\" <> _ -> parse_path(rest, pieces)\n        _ -> Error(Nil)\n      }\n\n    _ -> Error(Nil)\n  }\n}\n\nfn parse_port_loop(\n  uri_string: String,\n  pieces: Uri,\n  port: Int,\n) -> Result(Uri, Nil) {\n  case uri_string {\n    // As long as we find port numbers we keep accumulating those.\n    \"0\" <> rest -> parse_port_loop(rest, pieces, port * 10)\n    \"1\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 1)\n    \"2\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 2)\n    \"3\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 3)\n    \"4\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 4)\n    \"5\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 5)\n    \"6\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 6)\n    \"7\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 7)\n    \"8\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 8)\n    \"9\" <> rest -> parse_port_loop(rest, pieces, port * 10 + 9)\n\n    // `?` marks the beginning of the query with question mark.\n    \"?\" <> rest -> {\n      let pieces = Uri(..pieces, port: Some(port))\n      parse_query_with_question_mark(rest, pieces)\n    }\n\n    // `#` marks the beginning of the fragment part.\n    \"#\" <> rest -> {\n      let pieces = Uri(..pieces, port: Some(port))\n      parse_fragment(rest, pieces)\n    }\n\n    // `/` marks the beginning of a path.\n    \"/\" <> _ -> {\n      let pieces = Uri(..pieces, port: Some(port))\n      parse_path(uri_string, pieces)\n    }\n\n    // The string (and so the port) is over, we return what we parsed so far.\n    \"\" -> Ok(Uri(..pieces, port: Some(port)))\n\n    // In all other cases we've ran into some invalid character inside the port\n    // so the uri is invalid!\n    _ -> Error(Nil)\n  }\n}\n\nfn parse_path(uri_string: String, pieces: Uri) -> Result(Uri, Nil) {\n  parse_path_loop(uri_string, uri_string, pieces, 0)\n}\n\nfn parse_path_loop(\n  original: String,\n  uri_string: String,\n  pieces: Uri,\n  size: Int,\n) -> Result(Uri, Nil) {\n  case uri_string {\n    // `?` marks the beginning of the query with question mark.\n    \"?\" <> rest -> {\n      let path = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, path: path)\n      parse_query_with_question_mark(rest, pieces)\n    }\n\n    // `#` marks the beginning of the fragment part.\n    \"#\" <> rest -> {\n      let path = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, path: path)\n      parse_fragment(rest, pieces)\n    }\n\n    // If the string is over that means the entirety of the string was the path\n    // and it has an empty query and fragment.\n    \"\" -> Ok(Uri(..pieces, path: original))\n\n    // In all other cases the character is allowed to be part of the path so we\n    // just keep munching until we reach to its end.\n    _ -> {\n      let #(_, rest) = pop_codeunit(uri_string)\n      parse_path_loop(original, rest, pieces, size + 1)\n    }\n  }\n}\n\nfn parse_query_with_question_mark(\n  uri_string: String,\n  pieces: Uri,\n) -> Result(Uri, Nil) {\n  parse_query_with_question_mark_loop(uri_string, uri_string, pieces, 0)\n}\n\nfn parse_query_with_question_mark_loop(\n  original: String,\n  uri_string: String,\n  pieces: Uri,\n  size: Int,\n) -> Result(Uri, Nil) {\n  case uri_string {\n    // `#` marks the beginning of the fragment part.\n    \"#\" <> rest if size == 0 -> parse_fragment(rest, pieces)\n    \"#\" <> rest -> {\n      let query = codeunit_slice(original, at_index: 0, length: size)\n      let pieces = Uri(..pieces, query: Some(query))\n      parse_fragment(rest, pieces)\n    }\n\n    // If the string is over that means the entirety of the string was the query\n    // and it has an empty fragment.\n    \"\" -> Ok(Uri(..pieces, query: Some(original)))\n\n    // In all other cases the character is allowed to be part of the query so we\n    // just keep munching until we reach to its end.\n    _ -> {\n      let #(_, rest) = pop_codeunit(uri_string)\n      parse_query_with_question_mark_loop(original, rest, pieces, size + 1)\n    }\n  }\n}\n\nfn parse_fragment(rest: String, pieces: Uri) -> Result(Uri, Nil) {\n  Ok(Uri(..pieces, fragment: Some(rest)))\n}\n\n// WARN: this function returns invalid strings!\n// We need to return a String anyways to have this as the representation on the\n// JavaScript target.\n// Alternatively, we could rewrite the entire code to use a single\n// `fold_codeunits`-style loop and a state machine.\n@external(erlang, \"gleam_stdlib\", \"string_pop_codeunit\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"pop_codeunit\")\nfn pop_codeunit(str: String) -> #(Int, String)\n\n@external(erlang, \"binary\", \"part\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"string_codeunit_slice\")\nfn codeunit_slice(str: String, at_index from: Int, length length: Int) -> String\n\n/// Parses an URL-encoded query string into a list of key value pairs.\n/// Returns an error for invalid encoding.\n///\n/// The opposite operation is `uri.query_to_string`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// parse_query(\"a=1&b=2\")\n/// // -> Ok([#(\"a\", \"1\"), #(\"b\", \"2\")])\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"parse_query\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"parse_query\")\npub fn parse_query(query: String) -> Result(List(#(String, String)), Nil)\n\n/// Encodes a list of key value pairs as a URI query string.\n///\n/// The opposite operation is `uri.parse_query`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// query_to_string([#(\"a\", \"1\"), #(\"b\", \"2\")])\n/// // -> \"a=1&b=2\"\n/// ```\n///\npub fn query_to_string(query: List(#(String, String))) -> String {\n  query\n  |> list.map(query_pair)\n  |> list.intersperse(string_tree.from_string(\"&\"))\n  |> string_tree.concat\n  |> string_tree.to_string\n}\n\nfn query_pair(pair: #(String, String)) -> StringTree {\n  [percent_encode_query(pair.0), \"=\", percent_encode_query(pair.1)]\n  |> string_tree.from_strings\n}\n\nfn percent_encode_query(part: String) -> String {\n  percent_encode(part)\n  |> string.replace(each: \"+\", with: \"%2B\")\n}\n\n/// Encodes a string into a percent encoded representation.\n///\n/// ## Examples\n///\n/// ```gleam\n/// percent_encode(\"100% great\")\n/// // -> \"100%25%20great\"\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"percent_encode\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"percent_encode\")\npub fn percent_encode(value: String) -> String\n\n/// Decodes a percent encoded string.\n///\n/// ## Examples\n///\n/// ```gleam\n/// percent_decode(\"100%25%20great+fun\")\n/// // -> Ok(\"100% great+fun\")\n/// ```\n///\n@external(erlang, \"gleam_stdlib\", \"percent_decode\")\n@external(javascript, \"../gleam_stdlib.mjs\", \"percent_decode\")\npub fn percent_decode(value: String) -> Result(String, Nil)\n\n/// Splits the path section of a URI into its constituent segments.\n///\n/// Removes empty segments and resolves dot-segments as specified in\n/// [section 5.2](https://www.ietf.org/rfc/rfc3986.html#section-5.2) of the RFC.\n///\n/// ## Examples\n///\n/// ```gleam\n/// path_segments(\"/users/1\")\n/// // -> [\"users\" ,\"1\"]\n/// ```\n///\npub fn path_segments(path: String) -> List(String) {\n  remove_dot_segments(string.split(path, \"/\"))\n}\n\nfn remove_dot_segments(input: List(String)) -> List(String) {\n  remove_dot_segments_loop(input, [])\n}\n\nfn remove_dot_segments_loop(\n  input: List(String),\n  accumulator: List(String),\n) -> List(String) {\n  case input {\n    [] -> list.reverse(accumulator)\n    [segment, ..rest] -> {\n      let accumulator = case segment, accumulator {\n        \"\", accumulator -> accumulator\n        \".\", accumulator -> accumulator\n        \"..\", [] -> []\n        \"..\", [_, ..accumulator] -> accumulator\n        segment, accumulator -> [segment, ..accumulator]\n      }\n      remove_dot_segments_loop(rest, accumulator)\n    }\n  }\n}\n\n/// Encodes a `Uri` value as a URI string.\n///\n/// The opposite operation is `uri.parse`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let uri = Uri(..empty, scheme: Some(\"https\"), host: Some(\"example.com\"))\n/// to_string(uri)\n/// // -> \"https://example.com\"\n/// ```\n///\npub fn to_string(uri: Uri) -> String {\n  let parts = case uri.fragment {\n    Some(fragment) -> [\"#\", fragment]\n    None -> []\n  }\n  let parts = case uri.query {\n    Some(query) -> [\"?\", query, ..parts]\n    None -> parts\n  }\n  let parts = [uri.path, ..parts]\n  let parts = case uri.host, string.starts_with(uri.path, \"/\") {\n    Some(host), False if host != \"\" -> [\"/\", ..parts]\n    _, _ -> parts\n  }\n  let parts = case uri.host, uri.port {\n    Some(_), Some(port) -> [\":\", int.to_string(port), ..parts]\n    _, _ -> parts\n  }\n  let parts = case uri.scheme, uri.userinfo, uri.host {\n    Some(s), Some(u), Some(h) -> [s, \"://\", u, \"@\", h, ..parts]\n    Some(s), None, Some(h) -> [s, \"://\", h, ..parts]\n    Some(s), Some(_), None | Some(s), None, None -> [s, \":\", ..parts]\n    None, None, Some(h) -> [\"//\", h, ..parts]\n    _, _, _ -> parts\n  }\n  string.concat(parts)\n}\n\n/// Fetches the origin of a URI.\n///\n/// Returns the origin of a uri as defined in\n/// [RFC 6454](https://tools.ietf.org/html/rfc6454)\n///\n/// The supported URI schemes are `http` and `https`.\n/// URLs without a scheme will return `Error`.\n///\n/// ## Examples\n///\n/// ```gleam\n/// let assert Ok(uri) = parse(\"https://example.com/path?foo#bar\")\n/// origin(uri)\n/// // -> Ok(\"https://example.com\")\n/// ```\n///\npub fn origin(uri: Uri) -> Result(String, Nil) {\n  let Uri(scheme: scheme, host: host, port: port, ..) = uri\n  case host, scheme {\n    Some(h), Some(\"https\") if port == Some(443) ->\n      Ok(string.concat([\"https://\", h]))\n    Some(h), Some(\"http\") if port == Some(80) ->\n      Ok(string.concat([\"http://\", h]))\n    Some(h), Some(s) if s == \"http\" || s == \"https\" -> {\n      case port {\n        Some(p) -> Ok(string.concat([s, \"://\", h, \":\", int.to_string(p)]))\n        None -> Ok(string.concat([s, \"://\", h]))\n      }\n    }\n    _, _ -> Error(Nil)\n  }\n}\n\n/// Resolves a URI with respect to the given base URI.\n///\n/// The base URI must be an absolute URI or this function will return an error.\n/// The algorithm for merging URIs is described in\n/// [RFC 3986](https://tools.ietf.org/html/rfc3986#section-5.2).\n///\npub fn merge(base: Uri, relative: Uri) -> Result(Uri, Nil) {\n  case base {\n    Uri(scheme: Some(_), host: Some(_), ..) ->\n      case relative {\n        Uri(host: Some(_), ..) -> {\n          let path =\n            relative.path\n            |> string.split(\"/\")\n            |> remove_dot_segments()\n            |> join_segments()\n          let resolved =\n            Uri(\n              option.or(relative.scheme, base.scheme),\n              None,\n              relative.host,\n              option.or(relative.port, base.port),\n              path,\n              relative.query,\n              relative.fragment,\n            )\n          Ok(resolved)\n        }\n        _ -> {\n          let #(new_path, new_query) = case relative.path {\n            \"\" -> #(base.path, option.or(relative.query, base.query))\n            _ -> {\n              let path_segments = case string.starts_with(relative.path, \"/\") {\n                True -> string.split(relative.path, \"/\")\n                False ->\n                  base.path\n                  |> string.split(\"/\")\n                  |> drop_last()\n                  |> list.append(string.split(relative.path, \"/\"))\n              }\n              let path =\n                path_segments\n                |> remove_dot_segments()\n                |> join_segments()\n              #(path, relative.query)\n            }\n          }\n          let resolved =\n            Uri(\n              base.scheme,\n              None,\n              base.host,\n              base.port,\n              new_path,\n              new_query,\n              relative.fragment,\n            )\n          Ok(resolved)\n        }\n      }\n    _ -> Error(Nil)\n  }\n}\n\nfn drop_last(elements: List(a)) -> List(a) {\n  list.take(from: elements, up_to: list.length(elements) - 1)\n}\n\nfn join_segments(segments: List(String)) -> String {\n  string.join([\"\", ..segments], \"/\")\n}\n"}
